<html>
  <head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <script>
      var baseEnvJson = {};

      var envJsons = [];

      var lavaCanyon = {
        environment: {
          name: "Lava Canyon",
          danger: 7, // TODO
          enemyCount: 4,
          worldSize: 15,
        },
        floor_tile: {
          name: "Rock", // ground
          symbol: "‚ñ≤",
          backgroundColor: "#8B4513",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Lava", // group
            symbol: "‚âã",
            backgroundColor: "#FF4C00",
            color: "#FFFF00",
            rarity: 0.5,
            smoothness: 10,
          },
          {
            name: "Tree", // individual
            symbol: "‚ô†",
            backgroundColor: "#006400",
            color: "#FFFF00",
            rarity: 0.9,
            smoothness: 10,
          },
          {
            name: "Bones", // rare
            symbol: "‚ò†",
            backgroundColor: "#D3D3D3",
            color: "#FF0000",
            rarity: 0.99,
            smoothness: 10,
          },
        ],
        creature_types: [
          {
            name: "Dragon",
            symbol: "üêâ",
            color: "#ffff99",
          },
          {
            name: "Troll",
            symbol: "üëæ", // TODO
            color: "#ff5050",
          },
          {
            name: "Golem",
            symbol: "üíé",
            color: "#ccff99",
          },
        ],
      };

      var celestialRealm = {
        environment: {
          name: "Celestial Realm",
          danger: 9,
          enemyCount: 6,
          worldSize: 15,
        },
        floor_tile: {
          name: "Starlight",
          symbol: "‚ú¶",
          backgroundColor: "#000000",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Clouds",
            symbol: "‚òÅ",
            backgroundColor: "#FFFFFF",
            color: "#CCCCCC",
            rarity: 0.2,
            smoothness: 50,
          },
          {
            name: "Crystal",
            symbol: "‚ùñ",
            backgroundColor: "#87CEEB",
            color: "#FFFFFF",
            rarity: 0.5,
            smoothness: 30,
          },
          {
            name: "Feathers",
            symbol: "‚úø",
            backgroundColor: "#FFC0CB",
            color: "#FFFF00",
            rarity: 0.9,
            smoothness: 20,
          },
        ],
        creature_types: [
          {
            name: "Seraph",
            symbol: "üëº",
            color: "#FFD700",
          },
          {
            name: "Celestial Dragon",
            symbol: "üêâ",
            color: "#00CED1",
          },
          {
            name: "Astral Unicorn",
            symbol: "ü¶Ñ",
            color: "#FF69B4",
          },
        ],
      };

      var enchantedForest = {
        environment: {
          name: "Enchanted Forest",
          danger: 6,
          enemyCount: 5,
          worldSize: 15,
        },
        floor_tile: {
          name: "Moss",
          symbol: "‚ñ≤",
          backgroundColor: "#228B22",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Glowing Mushrooms",
            symbol: "‚âã",
            backgroundColor: "#8A2BE2",
            color: "#FFFF00",
            rarity: 0.6,
            smoothness: 25,
          },
          {
            name: "Ancient Trees",
            symbol: "‚ô†",
            backgroundColor: "#006400",
            color: "#FFD700",
            rarity: 0.5,
            smoothness: 30,
          },
          {
            name: "Magic Crystals",
            symbol: "‚ò†",
            backgroundColor: "#FF1493",
            color: "#00FFFF",
            rarity: 0.9,
            smoothness: 15,
          },
        ],
        creature_types: [
          {
            name: "Fairy",
            symbol: "üßö",
            color: "#FF69B4",
          },
          {
            name: "Elf",
            symbol: "üßù",
            color: "#008080",
          },
          {
            name: "Goblin",
            symbol: "üë∫",
            color: "#FFA500",
          },
        ],
      };

      var lavaFortress = {
        environment: {
          name: "Lava Fortress",
          danger: 9,
          enemyCount: 6,
          worldSize: 15,
        },
        floor_tile: {
          name: "Lava Rock",
          symbol: "‚ñ≤",
          backgroundColor: "#800000",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Lava Pool",
            symbol: "‚âã",
            backgroundColor: "#FF4500",
            color: "#FFD700",
            rarity: 0.2,
            smoothness: 50,
          },
          {
            name: "Volcanic Crater",
            symbol: "‚ô†",
            backgroundColor: "#8B0000",
            color: "#FF4500",
            rarity: 0.4,
            smoothness: 40,
          },
          {
            name: "Bones",
            symbol: "‚ò†",
            backgroundColor: "#D3D3D3",
            color: "#FF0000",
            rarity: 0.999,
            smoothness: 5,
          },
        ],
        creature_types: [
          {
            name: "Fire Elemental",
            symbol: "üúÑ",
            color: "#FF4500",
          },
          {
            name: "Magma Beast",
            symbol: "üúÅ",
            color: "#FF8C00",
          },
          {
            name: "Lava Golem",
            symbol: "üúÉ",
            color: "#FF0000",
          },
        ],
      };

      var crystalCaverns = {
        environment: {
          name: "Crystal Caverns",
          danger: 9,
          enemyCount: 6,
          worldSize: 15,
        },
        floor_tile: {
          name: "Crystals",
          symbol: "‚ñ≤",
          backgroundColor: "#00CED1",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Stalactites",
            symbol: "‚âã",
            backgroundColor: "#808080",
            color: "#FFD700",
            rarity: 0.2,
            smoothness: 35,
          },
          {
            name: "Glowing Mushrooms",
            symbol: "‚ô†",
            backgroundColor: "#00FF00",
            color: "#8A2BE2",
            rarity: 0.9,
            smoothness: 15,
          },
          {
            name: "Crystal Skulls",
            symbol: "‚ò†",
            backgroundColor: "#C0C0C0",
            color: "#FF1493",
            rarity: 0.999,
            smoothness: 10,
          },
        ],
        creature_types: [
          {
            name: "Crystal Golem",
            symbol: "üíé",
            color: "#00BFFF",
          },
          {
            name: "Luminous Serpent",
            symbol: "üêç",
            color: "#00FF00",
          },
          {
            name: "Spectral Spider",
            symbol: "üï∑",
            color: "#9400D3",
          },
        ],
      };

      var mistyMoorlands = {
        environment: {
          name: "Misty Moorlands",
          danger: 6,
          enemyCount: 5,
          worldSize: 15,
        },
        floor_tile: {
          name: "Moor",
          symbol: "‚ñ≤",
          backgroundColor: "#B0C4DE",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Mist",
            symbol: "‚âã",
            backgroundColor: "#D3D3D3",
            color: "#7B68EE",
            rarity: 0.5,
            smoothness: 25,
          },
          {
            name: "Dead Tree",
            symbol: "‚ô†",
            backgroundColor: "#A0522D",
            color: "#696969",
            rarity: 0.9,
            smoothness: 15,
          },
          {
            name: "Ancient Ruins",
            symbol: "‚ò†",
            backgroundColor: "#8B0000",
            color: "#FFD700",
            rarity: 0.99,
            smoothness: 8,
          },
        ],
        creature_types: [
          {
            name: "Ghost",
            symbol: "üëª",
            color: "#F8F8FF",
          },
          {
            name: "Werewolf",
            symbol: "üê∫",
            color: "#483D8B",
          },
          {
            name: "Wisp",
            symbol: "üßö",
            color: "#FFD700",
          },
        ],
      };

      var whisperingWoods = {
        environment: {
          name: "Whispering Woods",
          danger: 6,
          enemyCount: 5,
          worldSize: 15,
        },
        floor_tile: {
          name: "Grassy Ground",
          symbol: "‚ñ≤",
          backgroundColor: "#7CCD7C",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Tall Grass",
            symbol: "‚âã",
            backgroundColor: "#D8BFD8",
            color: "#228B22",
            rarity: 0.5,
            smoothness: 30,
          },
          {
            name: "Mushrooms",
            symbol: "‚ô†",
            backgroundColor: "#FF4500",
            color: "#FFD700",
            rarity: 0.7,
            smoothness: 20,
          },
          {
            name: "Glowing Fireflies",
            symbol: "‚ò†",
            backgroundColor: "#ADD8E6",
            color: "#FF1493",
            rarity: 0.9,
            smoothness: 10,
          },
        ],
        creature_types: [
          {
            name: "Elk",
            symbol: "ü¶å",
            color: "#8B4513",
          },
          {
            name: "Owl",
            symbol: "ü¶â",
            color: "#663399",
          },
          {
            name: "Fairy",
            symbol: "üßö‚Äç‚ôÄÔ∏è",
            color: "#FF69B4",
          },
        ],
      };

      var timelessDesert = {
        environment: {
          name: "Timeless Desert",
          danger: 6,
          enemyCount: 5,
          worldSize: 15,
        },
        floor_tile: {
          name: "Sand",
          symbol: "‚ñ≤",
          backgroundColor: "#F0E68C",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Cacti",
            symbol: "‚âã",
            backgroundColor: "#006400",
            color: "#FFD700",
            rarity: 0.5,
            smoothness: 30,
          },
          {
            name: "Oasis",
            symbol: "‚ô†",
            backgroundColor: "#20B2AA",
            color: "#00FFFF",
            rarity: 0.9,
            smoothness: 10,
          },
          {
            name: "Ancient Ruins",
            symbol: "‚ò†",
            backgroundColor: "#D2B48C",
            color: "#A0522D",
            rarity: 0.99,
            smoothness: 5,
          },
        ],
        creature_types: [
          {
            name: "Scorpion",
            symbol: "ü¶Ç",
            color: "#8B4513",
          },
          {
            name: "Vulture",
            symbol: "ü¶Ö",
            color: "#800000",
          },
          {
            name: "Camel",
            symbol: "üê´",
            color: "#CD853F",
          },
        ],
      };

      var frozenTundra = {
        environment: {
          name: "Frozen Tundra",
          danger: 9,
          enemyCount: 6,
          worldSize: 15,
        },
        floor_tile: {
          name: "Snow",
          symbol: "‚ñ≤",
          backgroundColor: "#F0F8FF",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Icicles",
            symbol: "‚âã",
            backgroundColor: "#00BFFF",
            color: "#FFFFFF",
            rarity: 0.4,
            smoothness: 30,
          },
          {
            name: "Pine Tree",
            symbol: "‚ô†",
            backgroundColor: "#2E8B57",
            color: "#FFD700",
            rarity: 0.8,
            smoothness: 25,
          },
          {
            name: "Frozen Bones",
            symbol: "‚ò†",
            backgroundColor: "#D3D3D3",
            color: "#00FFFF",
            rarity: 0.99,
            smoothness: 10,
          },
        ],
        creature_types: [
          {
            name: "Snow Yeti",
            symbol: "üóø",
            color: "#E0FFFF",
          },
          {
            name: "Ice Dragon",
            symbol: "üêâ",
            color: "#B0E0E6",
          },
          {
            name: "Frost Wraith",
            symbol: "üëª",
            color: "#ADD8E6",
          },
        ],
      };

      var heartland = {
        environment: {
          name: "Heartland",
          danger: 5,
          enemyCount: 3,
          worldSize: 15,
        },
        floor_tile: {
          name: "Grass",
          symbol: "‚ñ≤",
          backgroundColor: "#5A864F",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Mist",
            symbol: "‚âã",
            backgroundColor: "#C0C0C0",
            color: "#DDDDDD",
            rarity: 0.4,
            smoothness: 10,
          },
          {
            name: "Tree",
            symbol: "‚ô†",
            backgroundColor: "#228B22",
            color: "#FFFFFF",
            rarity: 0.7,
            smoothness: 20,
          },
          {
            name: "Mushroom",
            symbol: "‚ô£",
            backgroundColor: "#964B00",
            color: "#FFD700",
            rarity: 0.95,
            smoothness: 10,
          },
        ],
        creature_types: [
          {
            name: "Owl",
            symbol: "ü¶â",
            color: "#704214",
          },
          {
            name: "Fox",
            symbol: "ü¶ä",
            color: "#FF4500",
          },
          {
            name: "Squirrel",
            symbol: "üêøÔ∏è",
            color: "#A0522D",
          },
        ],
      };

      var luminousGlades = {
        environment: {
          name: "Luminous Glades",
          danger: 6,
          enemyCount: 5,
          worldSize: 15,
        },
        floor_tile: {
          name: "Glowing Moss",
          symbol: "‚ñ≤",
          backgroundColor: "#00FF00",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Floating Orbs",
            symbol: "‚¶ø",
            backgroundColor: "#FFD700",
            color: "#800080",
            rarity: 0.4,
            smoothness: 25,
          },
          {
            name: "Luminous Trees",
            symbol: "‚ô†",
            backgroundColor: "#008000",
            color: "#FFFF00",
            rarity: 0.5,
            smoothness: 30,
          },
          {
            name: "Glowing Flowers",
            symbol: "‚ùÄ",
            backgroundColor: "#FF69B4",
            color: "#00FFFF",
            rarity: 0.85,
            smoothness: 15,
          },
        ],
        creature_types: [
          {
            name: "Glowbug",
            symbol: "üêû",
            color: "#FFD700",
          },
          {
            name: "Will-o'-the-Wisp",
            symbol: "üî•",
            color: "#FF4500",
          },
          {
            name: "Spirit Fox",
            symbol: "ü¶ä",
            color: "#00FF00",
          },
        ],
      };

      var floatingIslands = {
        environment: {
          name: "Floating Islands",
          danger: 8,
          enemyCount: 6,
          worldSize: 15,
        },
        floor_tile: {
          name: "Sky",
          symbol: "‚òÅ",
          backgroundColor: "#B0E2FF",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Floating Rock",
            symbol: "‚âã",
            backgroundColor: "#A9A9A9",
            color: "#808080",
            rarity: 0.3,
            smoothness: 30,
          },
          {
            name: "Glowing Crystal",
            symbol: "‚ô¶",
            backgroundColor: "#E6E6FA",
            color: "#FFD700",
            rarity: 0.2,
            smoothness: 40,
          },
          {
            name: "Waterfall",
            symbol: "‚òÇ",
            backgroundColor: "#1E90FF",
            color: "#ADD8E6",
            rarity: 0.9,
            smoothness: 15,
          },
        ],
        creature_types: [
          {
            name: "Sky Serpent",
            symbol: "üêâ",
            color: "#9932CC",
          },
          {
            name: "Winged Lion",
            symbol: "ü¶Å",
            color: "#FFA500",
          },
          {
            name: "Cloud Elemental",
            symbol: "üå©Ô∏è",
            color: "#FFFFFF",
          },
        ],
      };

      var rockyHighlands = {
        environment: {
          name: "Rocky Highlands",
          danger: 8,
          enemyCount: 5,
          worldSize: 15,
        },
        floor_tile: {
          name: "Rock",
          symbol: "‚ñ≤",
          backgroundColor: "#A9A9A9",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Boulders",
            symbol: "‚âã",
            backgroundColor: "#808080",
            color: "#FFA500",
            rarity: 0.3,
            smoothness: 40,
          },
          {
            name: "Pine Trees",
            symbol: "‚ô†",
            backgroundColor: "#006400",
            color: "#228B22",
            rarity: 0.7,
            smoothness: 30,
          },
          {
            name: "Mountain Goats",
            symbol: "üêê",
            backgroundColor: "#F0E68C",
            color: "#8B4513",
            rarity: 0.9,
            smoothness: 15,
          },
        ],
        creature_types: [
          {
            name: "Eagle",
            symbol: "ü¶Ö",
            color: "#FFD700",
          },
          {
            name: "Mountain Lion",
            symbol: "ü¶Å",
            color: "#FF8C00",
          },
          {
            name: "Bobcat",
            symbol: "üò∫",
            color: "#A52A2A",
          },
        ],
      };

      var mysticCaverns = {
        environment: {
          name: "Mystic Cavern",
          danger: 6,
          enemyCount: 5,
          worldSize: 15,
        },
        floor_tile: {
          name: "Stone",
          symbol: "‚ñ≤",
          backgroundColor: "#808080",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Glowing Crystals",
            symbol: "‚âã",
            backgroundColor: "#00FFFF",
            color: "#FFFFFF",
            rarity: 0.5,
            smoothness: 30,
          },
          {
            name: "Ancient Runes",
            symbol: "‚ô†",
            backgroundColor: "#A020F0",
            color: "#FFFF00",
            rarity: 0.8,
            smoothness: 20,
          },
          {
            name: "Fossilized Bones",
            symbol: "‚ò†",
            backgroundColor: "#D2B48C",
            color: "#FF0000",
            rarity: 0.999,
            smoothness: 10,
          },
        ],
        creature_types: [
          {
            name: "Wisp",
            symbol: "üåü",
            color: "#FFD700",
          },
          {
            name: "Shadow Beast",
            symbol: "üëª",
            color: "#7B68EE",
          },
          {
            name: "Crystal Elemental",
            symbol: "üíé",
            color: "#00CED1",
          },
        ],
      };

      var elementalWasteland = {
        environment: {
          name: "Elemental Wasteland",
          danger: 9,
          enemyCount: 6,
          worldSize: 15,
        },
        floor_tile: {
          name: "Cracked Earth",
          symbol: "‚ñ≤",
          backgroundColor: "#7F5230",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Burning Cracks",
            symbol: "‚âã",
            backgroundColor: "#FF4500",
            color: "#FFD700",
            rarity: 0.2,
            smoothness: 35,
          },
          {
            name: "Twisted Trees",
            symbol: "‚ô†",
            backgroundColor: "#8B4513",
            color: "#FFA500",
            rarity: 0.8,
            smoothness: 15,
          },
          {
            name: "Ancient Relics",
            symbol: "‚ò†",
            backgroundColor: "#DAA520",
            color: "#C0C0C0",
            rarity: 0.999,
            smoothness: 5,
          },
        ],
        creature_types: [
          {
            name: "Ember Elemental",
            symbol: "üî•",
            color: "#FF4500",
          },
          {
            name: "Earth Golem",
            symbol: "üóø",
            color: "#8B4513",
          },
          {
            name: "Abyssal Shadow",
            symbol: "üåë",
            color: "#000000",
          },
        ],
      };

      var underwaterCity = {
        environment: {
          name: "Underwater City",
          danger: 9,
          enemyCount: 6,
          worldSize: 15,
        },
        floor_tile: {
          name: "Seabed",
          symbol: "‚ñ≤",
          backgroundColor: "#008080",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Coral Reef",
            symbol: "‚âã",
            backgroundColor: "#FF4500",
            color: "#FFD700",
            rarity: 0.2,
            smoothness: 40,
          },
          {
            name: "Kelp Forest",
            symbol: "‚ô†",
            backgroundColor: "#006400",
            color: "#00FF00",
            rarity: 0.6,
            smoothness: 30,
          },
          {
            name: "Sunken Ship",
            symbol: "‚ò†",
            backgroundColor: "#A9A9A9",
            color: "#FF8C00",
            rarity: 0.9,
            smoothness: 25,
          },
        ],
        creature_types: [
          {
            name: "Shark",
            symbol: "ü¶à",
            color: "#0000CD",
          },
          {
            name: "Octopus",
            symbol: "üêô",
            color: "#8A2BE2",
          },
          {
            name: "Mermaid",
            symbol: "üßú‚Äç‚ôÄÔ∏è",
            color: "#00BFFF",
          },
        ],
      };

      var ancientRuins = {
        environment: {
          name: "Ancient Ruins",
          danger: 9,
          enemyCount: 6,
          worldSize: 15,
        },
        floor_tile: {
          name: "Mossy Stone",
          symbol: "‚ñ≤",
          backgroundColor: "#5C6E3A",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Cracked Pillars",
            symbol: "‚àû",
            backgroundColor: "#6D6E5A",
            color: "#D9D9D9",
            rarity: 0.2,
            smoothness: 45,
          },
          {
            name: "Ancient Vines",
            symbol: "‚àû",
            backgroundColor: "#317F43",
            color: "#7FFF00",
            rarity: 0.4,
            smoothness: 35,
          },
          {
            name: "Broken Statues",
            symbol: "‚ò•",
            backgroundColor: "#6D6E5A",
            color: "#DAA520",
            rarity: 0.9,
            smoothness: 20,
          },
        ],
        creature_types: [
          {
            name: "Guardian",
            symbol: "üóø",
            color: "#808080",
          },
          {
            name: "Spirit",
            symbol: "üëª",
            color: "#7B68EE",
          },
          {
            name: "Shadow",
            symbol: "üåë",
            color: "#696969",
          },
        ],
      };

      var whisperingSands = {
        environment: {
          name: "Whispering Sands",
          danger: 6,
          enemyCount: 5,
          worldSize: 15,
        },
        floor_tile: {
          name: "Sand",
          symbol: "‚ñ≤",
          backgroundColor: "#FFE4B5",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Cacti",
            symbol: "‚âã",
            backgroundColor: "#8B0000",
            color: "#FFD700",
            rarity: 0.5,
            smoothness: 15,
          },
          {
            name: "Palm Tree",
            symbol: "‚ô†",
            backgroundColor: "#006400",
            color: "#FFFF00",
            rarity: 0.8,
            smoothness: 20,
          },
          {
            name: "Skull",
            symbol: "‚ò†",
            backgroundColor: "#D3D3D3",
            color: "#FF4500",
            rarity: 0.95,
            smoothness: 10,
          },
        ],
        creature_types: [
          {
            name: "Sand Serpent",
            symbol: "üêç",
            color: "#CD853F",
          },
          {
            name: "Scorpion",
            symbol: "ü¶Ç",
            color: "#800000",
          },
          {
            name: "Desert Rat",
            symbol: "üêÄ",
            color: "#DAA520",
          },
        ],
      };

      var darkAbyss = {
        environment: {
          name: "Dark Abyss",
          danger: 9,
          enemyCount: 6,
          worldSize: 15,
        },
        floor_tile: {
          name: "Water",
          symbol: "‚âà",
          backgroundColor: "#000080",
          color: "#FFFFFF",
          canWalk: false,
        },
        prop_types: [
          {
            name: "Seaweed",
            symbol: "œü",
            backgroundColor: "#008000",
            color: "#00FFFF",
            rarity: 0.2,
            smoothness: 40,
          },
          {
            name: "Shipwreck",
            symbol: "‚õ¥",
            backgroundColor: "#1E90FF",
            color: "#FFFF00",
            rarity: 0.6,
            smoothness: 30,
          },
          {
            name: "Glowing Crystals",
            symbol: "‚ú¶",
            backgroundColor: "#483D8B",
            color: "#FF1493",
            rarity: 0.999,
            smoothness: 5,
          },
        ],
        creature_types: [
          {
            name: "Giant Squid",
            symbol: "ü¶ë",
            color: "#FF4500",
          },
          {
            name: "Ghost Shark",
            symbol: "üëª",
            color: "#FFD700",
          },
          {
            name: "Deep Sea Angler",
            symbol: "üé£",
            color: "#00CED1",
          },
        ],
      };

      // stats -- type, range, damage, health, attackSpeed, statEff, symbol
      var itemsJson = {
        fists: {
          type: "weapon",
          range: 0,
          damage: 1,
          health: 0,
          attackSpeed: 1,
          statEff: { stat: "none", amount: 0 },
          symbol: "‚öîÔ∏è",
          breakChance: 0,
        },
        rags: {
          type: "armor",
          range: 1,
          damage: 0,
          health: 1,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üõ°Ô∏è",
        },
        grass: {
          type: "item",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üóùÔ∏è",
        },
        water: {
          type: "potion",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üß™",
        },
        knife: {
          type: "weapon",
          range: 2,
          damage: 1,
          health: 0,
          attackSpeed: 1,
          statEff: { stat: "none", amount: 0 },
          symbol: "‚öîÔ∏è",
          breakChance: 10,
        },
        helmet: {
          type: "armor",
          range: 0,
          damage: 0,
          health: 1,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üõ°Ô∏è",
        },
        bow: {
          type: "weapon",
          range: 7,
          damage: 1,
          health: 0,
          attackSpeed: 1,
          statEff: { stat: "none", amount: 0 },
          symbol: "üèπ",
          breakChance: 15,
        },
        potion: {
          type: "potion",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "health", amount: 5 },
          symbol: "üß™",
        },
        key: {
          type: "item",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üóùÔ∏è",
        },
        healthBuff: {
          type: "item",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üìú",
        },
        experience: {
          type: "item",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "‚ú®",
        },
      };

      var creatureJSON = {};

      var seed = 0; // TODO
      var worldSize = 15;
      var worldData = [];
      var worldTable;
      var creaturesParent;
      var createTimestamp;

      // Reset after 100
      var numCreatures = 0;
      var numEffects = 0;
      var numWarnings = 0;

      var blocking = false;
      var walkSpeed = 0.9;
      var workSpeed = 1000;
      var selTile;
      var selCreature;
      var firstArea = true;
      var defaultSmoothness = 15; // TODO noise scale

      var menuId = 0;

      document.addEventListener("keydown", function (event) {
        if (event.key === "ArrowDown") {
          arrowDown();
        }
        if (event.key === "ArrowUp") {
          arrowUp();
        }
        if (event.key === "ArrowLeft") {
          arrowLeft();
        }
        if (event.key === "ArrowRight") {
          arrowRight();
        }
        if (event.key === "s") {
          arrowDown();
        }
        if (event.key === "w") {
          arrowUp();
        }
        if (event.key === "a") {
          arrowLeft();
        }
        if (event.key === "d") {
          arrowRight();
        }
        if (event.key === "Enter") {
          enter();
        }
        if (event.key === " ") {
          enter();
        }
      });

      function arrowDown() {
        bottomCooldown(500);
      }
      function arrowUp() {
        topCooldown(500);
      }
      function arrowLeft() {
        leftCooldown(500);
      }
      function arrowRight() {
        rightCooldown(2000);
      }
      function enter() {
        centerCooldown(200);
      }

      var worldMap = [];
      var worldMapSize = 200; // must be divisible by 5
      var worldCoords = [0, 0];

      function getCurEnvJsonId() {
        if (
          worldCoords[0] < (worldMapSize / 5) * 1 &&
          worldCoords[1] < (worldMapSize / 5) * 1
        ) {
          return 16;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 1 &&
          worldCoords[1] < (worldMapSize / 5) * 2
        ) {
          return 12;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 1 &&
          worldCoords[1] < (worldMapSize / 5) * 3
        ) {
          return 7;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 1 &&
          worldCoords[1] < (worldMapSize / 5) * 4
        ) {
          return 4;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 1 &&
          worldCoords[1] < (worldMapSize / 5) * 5
        ) {
          return 1;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 2 &&
          worldCoords[1] < (worldMapSize / 5) * 1
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 2 &&
          worldCoords[1] < (worldMapSize / 5) * 2
        ) {
          return 13;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 2 &&
          worldCoords[1] < (worldMapSize / 5) * 3
        ) {
          return 8;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 2 &&
          worldCoords[1] < (worldMapSize / 5) * 4
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 2 &&
          worldCoords[1] < (worldMapSize / 5) * 5
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 3 &&
          worldCoords[1] < (worldMapSize / 5) * 1
        ) {
          return 17;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 3 &&
          worldCoords[1] < (worldMapSize / 5) * 2
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 3 &&
          worldCoords[1] < (worldMapSize / 5) * 3
        ) {
          return 9;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 3 &&
          worldCoords[1] < (worldMapSize / 5) * 4
        ) {
          return 5;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 3 &&
          worldCoords[1] < (worldMapSize / 5) * 5
        ) {
          return 2;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 4 &&
          worldCoords[1] < (worldMapSize / 5) * 1
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 4 &&
          worldCoords[1] < (worldMapSize / 5) * 2
        ) {
          return 14;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 4 &&
          worldCoords[1] < (worldMapSize / 5) * 3
        ) {
          return 10;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 4 &&
          worldCoords[1] < (worldMapSize / 5) * 4
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 4 &&
          worldCoords[1] < (worldMapSize / 5) * 5
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 5 &&
          worldCoords[1] < (worldMapSize / 5) * 1
        ) {
          return 18;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 5 &&
          worldCoords[1] < (worldMapSize / 5) * 2
        ) {
          return 15;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 5 &&
          worldCoords[1] < (worldMapSize / 5) * 3
        ) {
          return 11;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 5 &&
          worldCoords[1] < (worldMapSize / 5) * 4
        ) {
          return 6;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 5 &&
          worldCoords[1] < (worldMapSize / 5) * 5
        ) {
          return 3;
        } else {
          return 0;
        }
      }

      var health = 10;
      var equippedWeapon = "";
      var equippedArmor = "";
      var equippedItem = "";
      var equippedPotion = "";
      var items = [];

      function getEquippedWeapon() {
        return itemsJson[equippedWeapon != "" ? equippedWeapon : "fists"];
      }
      function getEquippedArmor() {
        return itemsJson[equippedArmor != "" ? equippedArmor : "rags"];
      }
      function getEquippedItem() {
        return itemsJson[equippedItem != "" ? equippedItem : "grass"];
      }
      function getEquippedPotion() {
        return itemsJson[equippedPotion != "" ? equippedPotion : "water"];
      }
      function isEquipped(item) {
        return (
          equippedWeapon == item ||
          equippedArmor == item ||
          equippedItem == item ||
          equippedPotion == item
        );
      }
      function updateStats() {
        var sT = "Health: " + health + " / " + (10 + getStat("health", true));
        sT += "<br>range: " + getStat("range", false) + " tiles";
        sT += "<br>damage: " + getStat("damage", false);
        sT += "<br>attackSpeed: " + getStat("attackSpeed", false);
        document.getElementById("statsDiv").innerHTML = sT;

        var itemsDiv = document.getElementById("itemsDiv");
        itemsDiv.innerHTML =
          "Weapon: " + (equippedWeapon != "" ? equippedWeapon : "fists");
        itemsDiv.innerHTML +=
          "<br>" + "Armor: " + (equippedArmor != "" ? equippedArmor : "rags");
        itemsDiv.innerHTML +=
          "<br>" + "Item: " + (equippedItem != "" ? equippedItem : "grass");
        itemsDiv.innerHTML +=
          "<br>" +
          "Potion: " +
          (equippedPotion != "" ? equippedPotion : "water");

        updateInfoText();
      }

      function getCreatureDrop(creature) {
        if (creature.id.startsWith("Seraph")) {
          // TODO special drops
        } else {
          return getItemDrop();
        }
      }
      function getItemDrop() {
        if (getItemAmount("knife") < 1 && getItemAmount("bow") < 1) {
          var ranVal = randomRange(0, 1);
          if (ranVal == 0) {
            return "knife"; // TODO more base items
          } else if (ranVal == 1) {
            return "bow";
          }
        } else {
          var ranVal = randomRange(0, 4);
          if (ranVal == 0) {
            return "experience"; // TODO leveling
          } else if (ranVal == 1) {
            return "knife"; // TODO more base items
          } else if (ranVal == 2) {
            return "helmet";
          } else if (ranVal == 3) {
            return "bow";
          } else if (ranVal == 4) {
            return "potion";
          }
        }
      }

      var tileTypes = [
        { name: "Home", color: "#ff9f60", symbol: "‚ñ≤", act: "_sleep" },
        { name: "Dirt", color: "#aaff80", symbol: "#", act: "" },
        { name: "Rock", color: "#8c8c8c", symbol: "‚ô¶", act: "" },
        { name: "Tree", color: "#b32400", symbol: "‚ô£", act: "", value: 0 },
        {
          name: "Water",
          color: "#EEEEFF",
          backgroundColor: "#42e5f4",
          symbol: "~~",
          act: "_water",
        },
        { name: "Carrot", color: "#ffb84d", symbol: "#", act: "Carrot" },
        {
          name: "Path",
          color: "#d68563",
          backgroundColor: "#ffb619",
          symbol: "#",
        },
        {
          name: "Up",
          color: "#ffffff",
          backgroundColor: "#bfbfbf",
          symbol: "^",
          canWalk: true,
        },
        {
          name: "Down",
          color: "#ffffff",
          backgroundColor: "#bfbfbf",
          symbol: "v",
          canWalk: true,
        },
        {
          name: "Left",
          color: "#ffffff",
          backgroundColor: "#bfbfbf",
          symbol: "<",
          canWalk: true,
        },
        {
          name: "Right",
          color: "#ffffff",
          backgroundColor: "#bfbfbf",
          symbol: ">",
          canWalk: true,
        },
      ];

      var specialTiles = [];
      function updateSpecialTiles() {
        specialTiles = [
          { i: 0, j: Math.round(worldSize / 2), type: "Up" },
          {
            i: worldSize + 1,
            j: Math.round(worldSize / 2),
            type: "Down",
          },
          { i: Math.round(worldSize / 2), j: 0, type: "Left" },
          {
            i: Math.round(worldSize / 2),
            j: worldSize + 1,
            type: "Right",
          },
        ];
      }

      var movingCreatures = [];

      $(document).ready(function () {
        init();
      });

      function init() {
        worldTable = document.getElementById("world");
        creaturesParent = document.getElementById("creatures");
        envJsons = [
          lavaCanyon,
          celestialRealm,
          enchantedForest,
          lavaFortress,
          crystalCaverns,
          mistyMoorlands,
          whisperingWoods,
          timelessDesert,
          frozenTundra,
          heartland,
          luminousGlades,
          floatingIslands,
          elementalWasteland,
          rockyHighlands,
          mysticCaverns,
          ancientRuins,
          whisperingSands,
          underwaterCity,
          darkAbyss,
        ];
        worldCoords = [worldMapSize / 2, worldMapSize / 2];

        createWorldData();
        drawWorld();
        createCreature("player", 0, 0);
        createCreatures();

        firstArea = false;
      }

      function createWorldData() {
        baseEnvJson = envJsons[getCurEnvJsonId()];

        worldSize = baseEnvJson.environment.worldSize;
        updateSpecialTiles();

        baseEnvJson.prop_types.forEach((type, index) => {
          noise.seed(seed * index);

          var smoothness = type.smoothness || defaultSmoothness;

          for (i = 0; i < worldSize + 2; i++) {
            if (!worldData[i]) {
              worldData.push([]);
            }
            for (j = 0; j < worldSize + 2; j++) {
              if (!worldData[i][j]) {
                // TODO fix only first prop_type (group) being considered
                const noiseX =
                  (i + worldCoords[0] * (worldSize + 2)) / defaultSmoothness;
                const noiseY =
                  (j + worldCoords[1] * (worldSize + 2)) / defaultSmoothness;

                var tile;
                if (Math.abs(noise.simplex2(noiseX, noiseY)) >= type.rarity) {
                  tile = createTile(
                    i + "_" + j,
                    getStartingTileType(i, j, type.name)
                  );
                } else {
                  tile = createTile(
                    i + "_" + j,
                    getStartingTileType(i, j, null)
                  );
                }
                tile.id = i + "_" + j;
                worldData[i].push(tile);
              }
            }
          }
        });

        /* for (i = 0; i < worldSize + 2; i++) {
          if (!worldData[i]) {
            worldData.push([]);
          }
          for (j = 0; j < worldSize + 2; j++) {
            if (!worldData[i][j]) {
              var tile = createTile(i + "_" + j, getStartingTileType(i, j));
              tile.id = i + "_" + j;
              worldData[i].push(tile);
            }
          }
        } */

        document.getElementById("worldDiv").innerHTML =
          envJsons[getCurEnvJsonId()].environment.name +
          "<br>(X: " +
          worldCoords[0] +
          ", Y: " +
          worldCoords[1] +
          ")";

        updateStats();
        enableBars(true, 1000);

        createTimestamp = Date.now();
      }
      function recreateWorldData(playerDir) {
        worldSize = baseEnvJson.environment.worldSize;
        //updateSpecialTiles();

        worldData = [];
        clearCreatures();
        selTile = null;
        selCreature = null;

        var playerPosX = 0;
        var playerPosY = 0;
        if (playerDir == "down") {
          playerPosX = Math.round(worldSize / 2);
          playerPosY = worldSize + 1;

          worldCoords = [worldCoords[0], worldCoords[1] + 1];
        } else if (playerDir == "up") {
          playerPosX = Math.round(worldSize / 2);
          playerPosY = 0;

          worldCoords = [worldCoords[0], worldCoords[1] - 1];
        } else if (playerDir == "right") {
          playerPosX = worldSize + 1;
          playerPosY = Math.round(worldSize / 2);

          worldCoords = [worldCoords[0] - 1, worldCoords[1]];
        } else if (playerDir == "left") {
          playerPosX = 0;
          playerPosY = Math.round(worldSize / 2);

          worldCoords = [worldCoords[0] + 1, worldCoords[1]];
        } else {
          playerPosX = Math.round(worldSize / 2);
          playerPosY = Math.round(worldSize / 2);

          worldCoords = [worldCoords[0], worldCoords[1]];
        }

        createWorldData();
        drawWorld();

        createCreature("player", playerPosY, playerPosX);

        createCreatures();

        removeBuffs();

        setBlock(false);

        //updateStats();
        //enableBars(true, 1000);
      }

      function secondsSinceCreate() {
        const currentTime = Date.now();
        const timeDifference = currentTime - createTimestamp;
        const secondsSinceCreate = Math.floor(timeDifference / 1000);
        return secondsSinceCreate;
      }

      function createCreatures() {
        eC = randomRange(0, baseEnvJson.environment.enemyCount);
        for (h = 0; h < eC; h++) {
          createCreature(
            baseEnvJson.creature_types[
              randomRange(0, baseEnvJson.creature_types.length - 1)
            ].name,
            Math.round(randomRange(0, worldSize)),
            Math.round(randomRange(0, worldSize))
          );
        }
      }

      function drawWorld() {
        var worldString = "";
        for (i = 0; i < worldData.length; i++) {
          worldString += "<tr>";
          for (j = 0; j < worldData[i].length; j++) {
            var tile = worldData[i][j];
            worldString += createTileString(tile);
          }
          worldString += "</tr>";
        }
        worldTable.innerHTML = worldString;
      }

      function createTile(idString, tileType) {
        return {
          id: idString,
          type: tileType,
          creature: "",
        };
      }

      function getStartingTileType(i, j, suggestion) {
        var specialTile = specialTiles.find(function (e) {
          return e.i == i && e.j == j;
        });
        if (specialTile) {
          return getTileType(specialTile.type);
        }

        var suggestedTile = baseEnvJson.prop_types.find(function (e) {
          return e.name == suggestion;
        });
        if (suggestedTile) {
          return suggestedTile;
        }

        if (!specialTile && Math.random() > baseEnvJson.prop_types[1].rarity) {
          //return getTileType("Rock");
          return baseEnvJson.prop_types[1];
        }
        if (!specialTile && Math.random() > baseEnvJson.prop_types[2].rarity) {
          return baseEnvJson.prop_types[2];
        }

        return baseEnvJson.floor_tile;
      }

      function getTileType(typeName) {
        return (type = tileTypes.find(function (e) {
          return e.name == typeName;
        }));
      }
      function setTileType(id, tileTypeString) {
        var idParts = id.split("_");

        if (
          (idParts[0] == "0" && idParts[1] == "0") ||
          (idParts[0] == "0" && idParts[1] == "1")
        ) {
          return false;
        }

        worldData[idParts[0]][idParts[1]] = createTile(
          id,
          getTileType(tileTypeString)
        );

        drawWorld();

        return true;
      }

      function clickTile(id) {
        var idParts = id.split("_");
        var tile = worldData[idParts[0]][idParts[1]];

        //actOnTile(tile);

        // if (selCreature) {
        //   setSelCreature(selCreature);
        // }
        setSelTile(tile);
      }
      function clickCreature(creatureName, creatureNum) {
        var creatureElement = document.getElementById(
          creatureName + creatureNum.toString()
        );

        // if (selTile) {
        //   setSelTile(selTile);
        // }
        setSelCreature(creatureElement);
      }

      function setSelTile(tile) {
        if (!tile.type.canWalk) {
          return;
        }

        if (selTile != tile) {
          selTile = tile;
        } else {
          selTile = null;
        }
        drawWorld();
      }
      function setSelCreature(creature) {
        if (selCreature) {
          selCreature.style.backgroundColor = "";
        }

        if (selCreature != creature) {
          selCreature = creature;
          selCreature.style.backgroundColor = "rgba(255, 255, 102, 0.5)";
        } else {
          selCreature = null;
        }
      }

      function getTileTypeName(tileType) {
        var type = tileTypes.find(function (e) {
          return e.name == tileType.name;
        });
        return type.name;
      }

      function getCreatureTile(creature) {
        for (i = 0; i < worldSize + 2; i++) {
          for (j = 0; j < worldSize + 2; j++) {
            if (worldData[i][j].creature == creature.title) {
              return worldData[i][j];
            }
          }
        }
      }
      function getTileCreature(id) {
        var idParts = id.split("_");

        return worldData[idParts[0]][idParts[1]].creature;
      }
      function setTileCreature(id, creature) {
        var idParts = id.split("_");
        var tile = worldData[idParts[0]][idParts[1]];

        tile.creature = creature;
      }

      function actOnTile(tile) {
        if (!tile.type.act || tile.type.act == "") {
          return;
        }

        if (tile.type.act.substring(0, 1) == "_") {
          doSpecialAction(tile);
          return;
        } else {
          tile.type = getTileType(tile.type.act);

          drawWorld();
        }
      }
      function doSpecialAction(tile) {
        // TODO
        if (tile.type.act == "_sleep") {
          console.log("sleeping!");
        }

        drawWorld();
      }

      function createCreature(creatureName, posX, posY) {
        numCreatures++;
        if (numCreatures > 100) {
          // Set to 2 because player is 1
          numCreatures = 2;
        }

        // TODO multiplication by 25 should be based off tile width and spacing
        let div = document.createElement("div");
        if (creatureName == "player") {
          div.innerHTML =
            '<p style="top:' +
            posX * 25 +
            "; left:" +
            posY * 25 +
            '" id="creatureTBD" class="creature" title="creatureTBD">üßô‚Äç‚ôÇÔ∏è</p>';
        } else {
          div.innerHTML =
            "<p " +
            'data-health="3" ' +
            "onclick=clickCreature('" +
            creatureName +
            "','" +
            numCreatures.toString() +
            "')" +
            ' style="top:' +
            posX * 25 +
            "; left:" +
            posY * 25 +
            '" id="creatureTBD" class="creature" title="creatureTBD">' +
            getCreatureByName(creatureName).symbol +
            "</p>";
        }

        div.firstChild.id = creatureName + numCreatures.toString();
        div.firstChild.title = creatureName + numCreatures.toString();

        if (creatureName != "player") {
          div.firstChild.style.color = getCreatureByName(creatureName).color;
        }

        creaturesParent.appendChild(div);

        /* if (creatureName == "player" && !firstArea) {
          return;
        } */

        chooseNextAIAction(creatureName + numCreatures.toString());

        updateCreatureJSON(div.firstChild);
      }
      function clearCreatures() {
        while (creaturesParent.firstChild) {
          creaturesParent.removeChild(creaturesParent.firstChild);
        }
        numCreatures = 0;

        creatureJSON = {};
      }
      function getCreatureByName(name) {
        for (const creature of baseEnvJson.creature_types) {
          if (creature.name == name) {
            return creature;
          }
        }
        return null;
      }
      function creatureMoving(creature) {
        for (q = 0; q < movingCreatures.length; q++) {
          if (movingCreatures[q] == creature) {
            return true;
          }
        }
        return false;
      }

      function checkObjectType(obj) {
        if (typeof obj === "object") {
          if (obj instanceof HTMLElement) {
            return "creature";
          } else {
            return "tile";
          }
        } else {
          return "neither";
        }
      }

      function chooseNextAIAction(creature) {
        var creatureElement = document.getElementById(creature);
        if (!creatureElement) {
          return;
        }

        var tile;
        if (creature.startsWith("player")) {
          if (selTile != null) {
            tile = selTile;
          } else {
            tile = selCreature;
          }
        } else {
          if (Math.random() < 0.2) {
            createWarning("!", creatureElement, 2000);
            setTimeout(() => {
              createEffect(
                "üí•",
                creatureElement,
                document.getElementById("player1")
              );
            }, 2000);
          }

          tile = findRandomTile();
        }

        // If there is no logical tile to work
        if (!tile) {
          tile = findRandomTile();
        }

        moveCreature(
          creature,
          tile /* findRandomTileOfType(tile.type.name) */,
          !creature.startsWith("player")
        );
      }
      function moveCreature(creature, targetOrTile, doWork) {
        if (!targetOrTile) {
          return;
        }

        var isTile = checkObjectType(targetOrTile) == "tile";

        var creatureElement = document.getElementById(creature);
        var targetElement;

        if (isTile) {
          targetElement = document.getElementById(targetOrTile.id);

          if (!targetOrTile.type.canWalk) {
            chooseNextAIAction(creature);
            return;
          }
        } else {
          targetElement = targetOrTile;
        }

        if (!creatureElement) {
          return;
        }

        if (creatureMoving(creature)) {
          return;
        }
        movingCreatures.push(creature);

        if (isTile) {
          setTileCreature(targetOrTile.id, creature);
        }

        var posY = creatureElement.offsetTop - 20;
        var posX = creatureElement.offsetLeft;
        var interval = setInterval(frame, 10);
        function frame() {
          if (!document.body.contains(targetElement)) {
            if (isTile) {
              targetElement = document.getElementById(targetOrTile.id);
            } else {
              targetElement = targetOrTile;
            }
          }

          tilePosY = targetElement.offsetTop - 14;
          tilePosX = targetElement.offsetLeft + 7;

          if (checkPosition(posX, tilePosX, posY, tilePosY)) {
            clearInterval(interval);
            setTimeout(
              function () {
                if (creature.startsWith("player") && isTile) {
                  if (targetOrTile.type.name == "Up") {
                    recreateWorldData("down");
                  } else if (targetOrTile.type.name == "Down") {
                    recreateWorldData("up");
                  } else if (targetOrTile.type.name == "Left") {
                    recreateWorldData("right");
                  } else if (targetOrTile.type.name == "Right") {
                    recreateWorldData("left");
                  }
                }

                if (doWork) {
                  actOnTile(targetOrTile);
                }

                if (isTile) {
                  setTileCreature(targetOrTile.id, "");
                }

                movingCreatures = movingCreatures.filter(
                  (item) => item !== creature
                );

                chooseNextAIAction(creature);
              },
              doWork ? workSpeed : 500
            );
          } else {
            if (posY < tilePosY) {
              creatureElement.style.top = posY += walkSpeed;
            } else if (posY > tilePosY) {
              creatureElement.style.top = posY -= walkSpeed;
            }

            if (posX < tilePosX) {
              creatureElement.style.left = posX += walkSpeed;
            } else if (posX > tilePosX) {
              creatureElement.style.left = posX -= walkSpeed;
            }
          }
        }
      }

      function createWarning(symbol, creatureElement, removeTime) {
        numWarnings++;
        if (numWarnings > 100) {
          numWarnings = 1;
        }

        let div = document.createElement("div");
        div.innerHTML =
          '<p id="warning" class="effect" title="warning">' +
          symbol.toString() +
          "</p>";

        div.firstChild.id = "warning" + numWarnings.toString();
        div.firstChild.title = "warning" + numWarnings.toString();
        creaturesParent.appendChild(div);

        moveWarning(
          "warning" + numWarnings.toString(),
          creatureElement,
          removeTime
        );
      }
      function moveWarning(warning, sourceElement, removeTime) {
        var warningElement = document.getElementById(warning);

        if (!warningElement) {
          return;
        }

        if (sourceElement != null) {
          warningElement.style.top = sourceElement.offsetTop - 30;
          warningElement.style.left = sourceElement.offsetLeft + 5;
        }

        var posY = warningElement.offsetTop - 20;
        var posX = warningElement.offsetLeft;
        var interval = setInterval(frame, 10);

        setTimeout(() => {
          removeWarning(warningElement, interval);
        }, removeTime);

        function frame() {
          var targetPosY = sourceElement.offsetTop - 30;
          var targetPosX = sourceElement.offsetLeft + 5;

          if (!checkPosition(posX, targetPosX, posY, targetPosY)) {
            if (posY < targetPosY) {
              warningElement.style.top = posY += walkSpeed * 1.5;
            } else if (posY > targetPosY) {
              warningElement.style.top = posY -= walkSpeed * 1.5;
            }

            if (posX < targetPosX) {
              warningElement.style.left = posX += walkSpeed * 1.5;
            } else if (posX > targetPosX) {
              warningElement.style.left = posX -= walkSpeed * 1.5;
            }
          }
        }
      }
      function removeWarning(warning, interval) {
        clearInterval(interval);
        warning.remove();
      }

      function createEffect(char, source, target) {
        numEffects++;
        if (numEffects > 100) {
          numEffects = 1;
        }

        let div = document.createElement("div");
        div.innerHTML =
          '<p id="effect" class="effect" title="effect">' + char + "</p>";

        div.firstChild.id = "effect" + numEffects.toString();
        div.firstChild.title = "effect" + numEffects.toString();
        creaturesParent.appendChild(div);

        moveEffect("effect" + numEffects.toString(), source, target);
      }
      function moveEffect(effect, sourceElement, targetElement) {
        if (!targetElement) {
          return;
        }

        var effectElement = document.getElementById(effect);
        if (!effectElement) {
          return;
        }

        if (sourceElement != null) {
          effectElement.style.top = sourceElement.style.top;
          effectElement.style.left = sourceElement.style.left;
        }

        var targetCoords = [targetElement.offsetTop, targetElement.offsetLeft];

        var posY = effectElement.offsetTop - 20;
        var posX = effectElement.offsetLeft;
        var interval = setInterval(frame, 10);
        function frame() {
          // tilePosY = targetElement.offsetTop - 14;
          // tilePosX = targetElement.offsetLeft + 7;
          tilePosY = targetCoords[0] - 14;
          tilePosX = targetCoords[1] + 7;

          if (checkPosition(posX, tilePosX, posY, tilePosY)) {
            clearInterval(interval);
            setTimeout(function () {
              effectElement.parentElement.remove();
              if (
                getDistanceBetweenElementAndPoint(targetElement, targetCoords) <
                20
              ) {
                playerDamage(1);
              }
            }, 500);
          } else {
            if (posY < tilePosY) {
              effectElement.style.top = posY += walkSpeed * 1.5;
            } else if (posY > tilePosY) {
              effectElement.style.top = posY -= walkSpeed * 1.5;
            }

            if (posX < tilePosX) {
              effectElement.style.left = posX += walkSpeed * 1.5;
            } else if (posX > tilePosX) {
              effectElement.style.left = posX -= walkSpeed * 1.5;
            }
          }
        }
      }

      function getCreatureDistanceToTile(creature, i, j) {
        var creatureElement = document.getElementById(creature);
        var worldTile = document.getElementById(i + "_" + j);

        distX = worldTile.offsetLeft - creatureElement.offsetLeft;
        distY = worldTile.offsetTop - creatureElement.offsetTop;
        distance = Math.sqrt(distX * distX + distY * distY);
        return distance;
      }
      function getDistanceBetweenElements(i, j) {
        distX = i.offsetLeft - j.offsetLeft;
        distY = i.offsetTop - j.offsetTop;
        distance = Math.sqrt(distX * distX + distY * distY);
        return distance;
      }
      function getDistanceBetweenElementAndPoint(i, point) {
        distX = i.offsetLeft - point[1];
        distY = i.offsetTop - point[0];
        distance = Math.sqrt(distX * distX + distY * distY);
        return distance;
      }

      function findTileOfType(typeName) {
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            if (worldData[i][j].type.name == typeName) {
              return worldData[i][j];
            }
          }
        }
      }
      function findNearestTileOfType(creature, typeName) {
        var minDistance = 9999;
        var currentTile;
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            if (
              worldData[i][j].type.name == typeName &&
              getCreatureDistanceToTile(creature, i, j) < minDistance
            ) {
              minDistance = getCreatureDistanceToTile(creature, i, j);
              currentTile = worldData[i][j];
            }
          }
        }

        return currentTile;
      }
      /*function findValuedTile(creature) {
        var minDistance = 9999;
        var currentTile;
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            if (
              worldData[i][j].type.hasOwnProperty("value") &&
              worldData[i][j].type.value > 0 &&
              getCreatureDistanceToTile(creature, i, j) < minDistance
            ) {
              minDistance = getCreatureDistanceToTile(creature, i, j);
              currentTile = worldData[i][j];
            }
          }
        }
        return currentTile;
      }*/
      /* function findWorkableTile(creature, baseName) {
        var minDistance = 9999;
        var currentTile;
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            if (
              !(
                "Water Path Pen " +
                (baseName + "Home") +
                " Store Rock"
              ).includes(worldData[i][j].type.name) &&
              !worldData[i][j].watered &&
              getCreatureDistanceToTile(creature, i, j) < minDistance
            ) {
              minDistance = getCreatureDistanceToTile(creature, i, j);
              currentTile = worldData[i][j];
            }
          }
        }
        return currentTile;
      } */
      function findRandomTile() {
        return worldData[randomRange(0, worldSize - 1)][
          randomRange(0, worldSize - 1)
        ];
      }
      function findRandomTileOfType(typeName) {
        var rVal = 0;
        var currentTile;
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            var randomVal = Math.random();
            if (worldData[i][j].type.name == typeName && randomVal > rVal) {
              rVal = randomVal;
              currentTile = worldData[i][j];
            }
          }
        }
        return currentTile;
      }
      function findTileWithCreature(creature) {
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            if (worldData[i][j].creature.startsWith(creature)) {
              return worldData[i][j];
            }
          }
        }
      }
      function findTileWithID(id) {
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            if (worldData[i][j].id == id) {
              return worldData[i][j];
            }
          }
        }
      }

      function checkPosition(x, x2, y, y2) {
        return Math.abs(x - x2) + Math.abs(y - y2) < walkSpeed + 0.5;
      }
      function randomRange(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function playerAttack() {
        if (!selCreature) {
          return;
        }

        var attackRange = Math.max(30 * getStat("range", false), 30);
        var shooting = getStat("range", false) > 3;

        var playerElement = document.getElementById("player1");
        if (
          getDistanceBetweenElements(playerElement, selCreature) <= attackRange
        ) {
          if (shooting) {
            createEffect("üí•", playerElement, selCreature);
          }

          selCreature.dataset.health -= getStat("damage", false);
          createWarning("hit", playerElement, 400);

          if (selCreature.dataset.health <= 0) {
            creatureDeath(selCreature);
          } else {
            updateCreatureJSON(selCreature);
          }
        } else {
          createWarning("range", playerElement, 500);
        }

        if (equippedWeapon != "") {
          var ranBreak = randomRange(1, 100);
          if (ranBreak <= getEquippedWeapon().breakChance) {
            removeItem(equippedWeapon, 1);
            createWarning("broke", playerElement, 800);
          }
        }
      }
      function creatureDeath(creature) {
        updateCreatureJSON(creature);

        addItem(getCreatureDrop(creature), 1);

        creaturesParent.removeChild(creature.parentElement);

        selCreature = null;
      }

      function getStat(stat, excludeBuffs) {
        if (stat == "range") {
          return (
            getEquippedWeapon().range +
            getEquippedArmor().range +
            getEquippedItem().range +
            getEquippedPotion().range +
            (!excludeBuffs ? getItemAmount("rangeBuff") : 0)
          );
        } else if (stat == "damage") {
          return (
            getEquippedWeapon().damage +
            getEquippedArmor().damage +
            getEquippedItem().damage +
            getEquippedPotion().damage +
            (!excludeBuffs ? getItemAmount("damageBuff") : 0)
          );
        } else if (stat == "health") {
          return (
            getEquippedWeapon().health +
            getEquippedArmor().health +
            getEquippedItem().health +
            getEquippedPotion().health +
            (!excludeBuffs ? getItemAmount("healthBuff") : 0)
          );
        } else if (stat == "attackSpeed") {
          return (
            getEquippedWeapon().attackSpeed +
            getEquippedArmor().attackSpeed +
            getEquippedItem().attackSpeed +
            getEquippedPotion().attackSpeed +
            (!excludeBuffs ? getItemAmount("attackSpeedBuff") : 0)
          );
        }
      }
      function changeStat(stat, amount) {
        if (stat == "health") {
          health += amount;

          if (health <= 0) {
            playerDeath();
          }
        }

        updateStats();
      }
      function playerDamage(amount) {
        if (secondsSinceCreate() < 5) {
          return;
        }

        if (!blocking) {
          changeStat("health", -amount);
        } else {
          setBlock(false);
        }
      }

      function playerDeath() {
        health = 10 + getStat("health", false);

        recreateWorldData("none");
      }

      function updateCreatureJSON(creature) {
        if (creature.id.startsWith("player")) {
          return;
        }

        if (!creature.dataset.health) {
          return;
        }

        var newItem = { name: creature.id, health: creature.dataset.health };
        creatureJSON[newItem.name] = newItem;

        updateInfoText();
      }
      function updateInfoText() {
        var retText = "";
        Object.keys(creatureJSON).forEach((key) => {
          const creature = creatureJSON[key];
          retText +=
            creature.name +
            "<br>" +
            " - health: " +
            creature.health +
            "<br><br>";
        });
        document.getElementById("creatureText").innerHTML = retText;

        retText = "";
        if (items.length > 0) {
          for (i = 0; i < items.length; i++) {
            iJson = itemsJson[items[i][0]];
            retText +=
              (menuId == i ? " > " : "") +
              (isEquipped(items[i][0]) ? "E " : "") +
              (menuId != i ? " - " : "") +
              iJson.symbol +
              " " +
              items[i][0] +
              " x" +
              items[i][1] +
              (menuId == i
                ? "<br>" +
                  iJson.type +
                  (iJson.range != 0 ? " range:" + iJson.range : "") +
                  (iJson.damage != 0 ? " damage:" + iJson.damage : "") +
                  (iJson.health != 0 ? " health:" + iJson.health : "") +
                  (iJson.attackSpeed != 0 ? " dex:" + iJson.attackSpeed : "") +
                  (iJson.statEff.stat != "none"
                    ? "<br>effect: " +
                      iJson.statEff.stat +
                      " (" +
                      iJson.statEff.amount +
                      ")"
                    : "") +
                  "<br>"
                : "") +
              "<br>";
          }
        }
        document.getElementById("invText").innerHTML = retText;
      }

      // stats -- type, range, damage, health, attackSpeed, statEff, symbol
      function addItem(addItem, amount) {
        var added = false;

        for (i = 0; i < items.length; i++) {
          if (items[i][0] == addItem) {
            items[i][1] += amount;
            added = true;
          }
        }

        if (!added) {
          items.push([addItem, amount]);
        }

        updateStats();
      }
      function removeItem(removeItem, amount) {
        for (i = 0; i < items.length; i++) {
          if (items[i][0] == removeItem) {
            items[i][1] -= amount;

            if (items[i][1] <= 0) {
              items = items.filter((item) => item[0] !== removeItem);

              if (removeItem == equippedWeapon) {
                equippedWeapon = "";
              } else if (removeItem == equippedArmor) {
                equippedArmor = "";
              } else if (removeItem == equippedPotion) {
                equippedPotion = "";
              } else if (removeItem == equippedItem) {
                equippedItem = "";
              }
            }
          }
        }

        updateStats();
      }
      function equipItem(equipItem) {
        if (!equipItem || equipItem == "") {
          return;
        }

        for (i = 0; i < items.length; i++) {
          if (items[i][0] == equipItem) {
            var iObj = itemsJson[items[i][0]];
            if (iObj.type == "weapon") {
              equippedWeapon = equippedWeapon != equipItem ? equipItem : "";
            } else if (iObj.type == "armor") {
              equippedArmor = equippedArmor != equipItem ? equipItem : "";
            } else if (iObj.type == "potion") {
              equippedPotion = equippedPotion != equipItem ? equipItem : "";
            } else if (iObj.type == "item") {
              equippedItem = equippedItem != equipItem ? equipItem : "";
            }
          }
        }

        updateStats();
      }
      function useItem(useItem) {
        if (!useItem || useItem == "") {
          return;
        }

        for (i = 0; i < items.length; i++) {
          if (items[i][0] == useItem) {
            var iObj = itemsJson[items[i][0]];
            if (iObj.statEff.stat == "range") {
              addItem("rangeBuff", iObj.statEff.amount);
            }
            if (iObj.statEff.stat == "damage") {
              addItem("damageBuff", iObj.statEff.amount);
            }
            if (iObj.statEff.stat == "health") {
              addItem("healthBuff", iObj.statEff.amount);
              health = 10 + getStat("health", false);
            }
            if (iObj.statEff.stat == "attackSpeed") {
              addItem("attackSpeedBuff", iObj.statEff.amount);
            }

            if (iObj.type == "potion") {
              removeItem(useItem, 1);
            } else if (iObj.type == "item") {
              // TODO enter dungeon
            }

            var playerElement = document.getElementById("player1");
            createWarning("| | |", playerElement, 500);
          }
        }
      }
      function getItemAmount(amntItem) {
        for (i = 0; i < items.length; i++) {
          if (items[i][0] == amntItem) {
            return items[i][1];
          }
        }
        return 0;
      }
      function removeBuffs(removeItem, amount) {
        items = items.filter((item) => !item[0].endsWith("Buff"));

        if (health > 10 + getStat("health", true)) {
          health = 10 + getStat("health", true);
        }

        updateStats();
      }

      /*function save() {
        var saveString = "";

        saveString += points.toString() + "*";
        saveString += day.toString() + "*";
        saveString += numHouses.toString() + "*";
        saveString += cowHouses.toString() + "*";
        saveString += purchasedUpgradeString + "*";
        for (x = 0; x < worldSize; x++) {
          for (y = 0; y < worldSize; y++) {
            var tile = worldData[x][y];
            saveString += saveTileToString(tile) + "+";
          }
        }

        document.getElementById("save").value = saveString;
      }
      function load() {
        var loadElement = document.getElementById("load");

        var loadString = loadElement.value.split("*");

        points = parseInt(loadString[0]);
        day = parseInt(loadString[1]);
        numHouses = parseInt(loadString[2]);
        cowHouses = parseInt(loadString[3]);
        var upgradeString = loadString[4].split("+");
        for (upg = 0; upg < upgradeString.length - 1; upg++) {
          switch (upgradeString[upg]) {
            case "world":
              purchaseUpgrade(getUpgrade("world"), true);
              break;
            case "shoes":
              purchaseUpgrade(getUpgrade("shoes"), true);
              break;
            case "tool":
              purchaseUpgrade(getUpgrade("tool"), true);
              break;
            case "wc":
              purchaseUpgrade(getUpgrade("wc"), true);
              break;
            case "fertilizer":
              purchaseUpgrade(getUpgrade("fertilizer"), true);
              break;
            case "worlders":
              purchaseUpgrade(getUpgrade("worlders"), true);
              break;
            case "cows":
              purchaseUpgrade(getUpgrade("cows"), true);
              break;
          }
        }

        var worldDataString = loadString[5].split("+");
        for (fd = 0; fd < worldDataString.length - 1; fd++) {
          loadTileFromString(worldDataString[fd]);
        }

        drawWorld();
      }

      function saveTileToString(tile) {
        return tile.id + "&" + tile.watered + "&" + getTileTypeName(tile.type);
      }
      function loadTileFromString(tileString) {
        var tileData = tileString.split("&");

        setTileType(tileData[0], tileData[2]);

        var idParts = tileData[0].split("_");
        worldData[idParts[0]][idParts[1]].watered = tileData[1] === "true";
      }*/

      function createTileString(tile) {
        return (
          "<td class='tile' " +
          " id='" +
          tile.id +
          "'" +
          " style='color:" +
          tile.type.color +
          ";" +
          " background-color: " +
          getTileBackgroundColor(tile) +
          ";" +
          getBorderStyle(tile) +
          /* getOpacity(tile) */ "" +
          "; user-select: none; '" +
          " onclick='clickTile(this.id)' " +
          " title='" +
          tile.type.name +
          "'" +
          ">" +
          tile.type.symbol
        );
        ("</td>");
      }
      function getTileBackgroundColor(tile) {
        if (selTile == tile) {
          return "#ffff99";
        } else {
          return tile.type.backgroundColor
            ? tile.type.backgroundColor
            : "#ccffb3";
        }
      }
      function getTileBorderColor(tile) {
        if (selTile == tile) {
          return "#ffff99";
        } else {
          return tile.type.backgroundColor
            ? darkenColor(tile.type.backgroundColor, 20)
            : "#4ce600";
        }
      }
      function getBorderStyle(tile) {
        var tileString = "";
        var borderString = " 2pt solid " + getTileBorderColor(tile) + "; ";
        tileString += " border-bottom: " + borderString + ";";
        tileString += " border-top: " + borderString + ";";
        tileString += " border-right: " + borderString + ";";
        tileString += " border-left: " + borderString + ";";
        return tileString;
      }
      /*function getOpacity(tile) {
        if (
          parseInt(tile.id.split("_")[0]) > worldSize ||
          parseInt(tile.id.split("_")[1]) > worldSize
        ) {
          return " opacity: .2; ";
        }

        if (
          parseInt(tile.id.split("_")[0]) > worldSize - 1 ||
          parseInt(tile.id.split("_")[1]) > worldSize - 1
        ) {
          return " opacity: .5; ";
        }
        return "";
      }*/

      function darkenColor(hexColor, percentage) {
        // Remove the "#" symbol if present
        hexColor = hexColor.replace("#", "");

        // Convert the hexadecimal color to RGB values
        const r = parseInt(hexColor.substring(0, 2), 16);
        const g = parseInt(hexColor.substring(2, 4), 16);
        const b = parseInt(hexColor.substring(4, 6), 16);

        // Calculate the darker RGB values based on the percentage
        const darkerR = Math.floor(r * (1 - percentage / 100));
        const darkerG = Math.floor(g * (1 - percentage / 100));
        const darkerB = Math.floor(b * (1 - percentage / 100));

        // Convert the darker RGB values back to hexadecimal color
        const darkerHexColor =
          "#" +
          darkerR.toString(16).padStart(2, "0") +
          darkerG.toString(16).padStart(2, "0") +
          darkerB.toString(16).padStart(2, "0");

        return darkerHexColor;
      }
    </script>

    <style>
      .tile {
        width: 20px;
        height: 10px;
        text-align: center;
        font-weight: bold;
      }
      .creature {
        position: fixed;
        top: 0px;
        left: 0px;
        z-index: 2;
        color: rgb(204, 51, 0);
        text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
        font-size: 14pt;
        font-weight: bold;
        padding-top: 2px;
        padding-left: 2px;
        user-select: none;
        padding: 5px;
      }
      .effect {
        position: fixed;
        top: 0px;
        left: 0px;
        z-index: 2;
        color: #cc3300;
        text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
        font-size: 14pt;
        font-weight: bold;
        padding-top: 2px;
        padding-left: 2px;
        user-select: none;
      }
    </style>
  </head>

  <body class="container">
    <div>
      <table class="table-container" id="world"></table>
      <p id="creatures"></p>
      <div id="worldDiv" class="stats-text"></div>
    </div>

    <div>
      <div class="panel">
        <div class="panel-content">
          <div id="statsDiv" class="stats-text"></div>
          <br />
          <div id="itemsDiv" class="stats-text"></div>
        </div>
      </div>

      <br />

      <div class="panel">
        <div class="panel-container">
          <div style="grid-area: top">
            <button id="topButton" onclick="arrowUp()">
              <span id="topText" class="button-text"></span>
              <div id="topBLoad" class="loading-bar"></div>
            </button>
          </div>
          <div style="grid-area: left">
            <button id="leftButton" onclick="arrowLeft()">
              <span id="leftText" class="button-text"></span>
              <div id="leftBLoad" class="loading-bar"></div>
            </button>
          </div>
          <div style="grid-area: center">
            <button id="centerButton" onclick="enter()">
              <span id="blockText" class="button-text">‚öîÔ∏è</span>
              <div id="centerBLoad" class="loading-bar"></div>
            </button>
          </div>
          <div style="grid-area: right">
            <button id="rightButton" onclick="arrowRight()">
              <span id="rightText" class="button-text"></span>
              <div id="rightBLoad" class="loading-bar"></div>
            </button>
          </div>
          <div style="grid-area: bottom">
            <button id="bottomButton" onclick="arrowDown()">
              <span id="bottomText" class="button-text"></span>
              <div id="bottomBLoad" class="loading-bar"></div>
            </button>
          </div>
        </div>
      </div>
    </div>

    <div>
      <div class="panel">
        <div class="panel-content">
          <div id="creatureText" class="stats-text"></div>
        </div>
      </div>
      <br />
      <div class="panel">
        <div class="panel-content">
          <div id="invText" class="stats-text"></div>
        </div>
      </div>
    </div>

    <!-- <div>
      <br />
      <button onclick="save()">Save</button>
      <input id="save" style="user-select: none" />
    </div>
    <div id="loading" style="display: inline">
      <input id="load" />
      <button onclick="load()">Load</button>
    </div> -->
  </body>
</html>

<style>
  .container {
    display: inline-flex;
    overflow: hidden;
  }

  .table-container {
    width: 480px;
    padding: 0px;
  }

  .panel {
    /* width: 300px; */
    height: 200px;
    border: 1px solid #ccc;
    overflow: hidden;
    margin-left: 10px;
    justify-items: center;
    align-items: center;
  }

  .panel-container {
    display: grid;
    grid-template-areas:
      "top top top"
      "left center right"
      "bottom bottom bottom";
    gap: 20px;
    height: 100%;
    justify-items: center;
    align-items: center;
    background-color: #d8b68b;
  }

  .panel-content {
    width: 250px;
    padding: 10px;
    overflow-y: auto;
    height: calc(100% - 20px); /* Subtract padding */
    background-color: #d8b68b;
  }

  button {
    position: relative;
    padding: 10px 20px;
    font-size: 16px;
    background-color: #daba91;
    border: none;
    cursor: pointer;
  }

  button:disabled {
    cursor: default;
    pointer-events: all !important;
  }

  .button-text {
    font-family: fantasy, Tahoma, Geneva, Verdana, sans-serif;
    color: #827056;
    position: relative;
    z-index: 2;
  }

  .loading-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    background-color: #543c25;
    transition: width 0.5s linear;
    z-index: 1;
  }

  .stats-text {
    font-family: fantasy, Tahoma, Geneva, Verdana, sans-serif;
    color: #827056;
  }
</style>

<script>
  const blockText = document.getElementById("blockText");

  let repeatIntervalId;
  repeatIntervalId = setInterval(repeatFunction, 500);

  // Action bars
  const topButton = document.getElementById("topButton");
  const topBLoad = document.getElementById("topBLoad");
  let topCooldownTime = 5;
  const rightButton = document.getElementById("rightButton");
  const rightBLoad = document.getElementById("rightBLoad");
  let rightCooldownTime = 5;
  const bottomButton = document.getElementById("bottomButton");
  const bottomBLoad = document.getElementById("bottomBLoad");
  let bottomCooldownTime = 5;
  const leftButton = document.getElementById("leftButton");
  const leftBLoad = document.getElementById("leftBLoad");
  let leftCooldownTime = 5;
  const centerButton = document.getElementById("centerButton");
  const centerBLoad = document.getElementById("centerBLoad");
  let centerCooldownTime = 5;

  let actType = "top";
  let intervalId;

  // Top
  function topCooldown(time) {
    // actType = "top";
    // enableBars(false, time);
    // topBLoad.style.width = "0%";
    // intervalId = setInterval(updateLoadingBar, time);

    menuId--;
    if (menuId < 0) {
      menuId = 0;
    }

    updateStats();
  }
  // Left
  function leftCooldown(time) {
    // actType = "left";
    // enableBars(false, time);
    // leftBLoad.style.width = "0%";
    // intervalId = setInterval(updateLoadingBar, time);

    if (menuId <= items.length) {
      useItem(items[menuId][0]);
    }
  }
  // Right
  function rightCooldown(time) {
    if (selCreature != null) {
      if (!rightButton.disabled) {
        console.log(intervalId); // TODO attack delay
        playerAttack();
        rightButton.disabled = true;
      }

      var aS = getStat("attackSpeed", false);
      if (aS >= 1 && aS < 5) {
        time = 1500;
      } else if (aS >= 5 && aS < 10) {
        time = 1000;
      } else if (aS >= 10 && aS < 15) {
        time = 800;
      } else if (aS >= 15) {
        time = 500;
      } else {
        time = 2000;
      }

      //actType = "right";
      //enableBars(false, time);
      //rightBLoad.style.width = "0%";
      //intervalId = setInterval(updateLoadingBar, time);

      intervalId = setInterval(enableRightButton, time);
    } else {
      if (menuId <= items.length) {
        equipItem(items[menuId][0]);
      }

      updateStats();
    }
  }
  // Down
  function bottomCooldown(time) {
    // actType = "bottom";
    // enableBars(false, time);
    // bottomBLoad.style.width = "0%";
    // intervalId = setInterval(updateLoadingBar, time);

    menuId++;
    if (menuId >= items.length) {
      menuId = items.length - 1;
    }

    updateStats();
  }
  // Center
  function centerCooldown(time) {
    // actType = "center";
    // enableBars(false, time);
    // centerBLoad.style.width = "0%";
    // intervalId = setInterval(updateLoadingBar, time);

    setBlock(!blocking);
  }

  function enableRightButton() {
    clearInterval(intervalId);
    rightButton.disabled = false;
  }

  function enableBars(enable, time) {
    if (time < 0) {
      topButton.disabled = !enable;
      rightButton.disabled = !enable;
      bottomButton.disabled = !enable;
      leftButton.disabled = !enable;
      centerButton.disabled = false;
      return;
    }

    setBlock(false); // TODO remove?

    topButton.disabled = !enable;
    rightButton.disabled = !enable;
    bottomButton.disabled = !enable;
    leftButton.disabled = !enable;
    centerButton.disabled = !enable;

    topCooldownTime = time / 1000;
    rightCooldownTime = time / 1000;
    bottomCooldownTime = time / 1000;
    leftCooldownTime = time / 1000;
    centerCooldownTime = time / 1000;
    topBLoad.style.width = "100%";
    rightBLoad.style.width = "100%";
    bottomBLoad.style.width = "100%";
    leftBLoad.style.width = "100%";
    centerBLoad.style.width = "100%";
  }

  /* function updateLoadingBar(time) {
    if (actType == "top") {
      topCooldownTime--;
      topBLoad.style.width =
        "0%";
      if (topCooldownTime <= 0) {
        clearInterval(intervalId);
        enableBars(true);
      }
    } else if (actType == "right") {
      rightCooldownTime--;
      rightBLoad.style.width =
        "0%";
      if (rightCooldownTime <= 0) {
        clearInterval(intervalId);
        enableBars(true);
      }
    } else if (actType == "bottom") {
      bottomCooldownTime--;
      bottomBLoad.style.width =
        "0%";
      if (bottomCooldownTime <= 0) {
        clearInterval(intervalId);
        enableBars(true);
      }
    } else if (actType == "left") {
      leftCooldownTime--;
      leftBLoad.style.width =
        "0%";
      if (leftCooldownTime <= 0) {
        clearInterval(intervalId);
        enableBars(true);
      }
    } else if (actType == "center") {
      centerCooldownTime--;
      centerBLoad.style.width =
        "0%";
      if (centerCooldownTime <= 0) {
        clearInterval(intervalId);
        enableBars(true);
      }
    }
  } */

  function setBlock(block) {
    blocking = block;
    //enableBars(!blocking, -1);
    blockText.innerHTML = blocking ? "üõ°Ô∏è" : "‚öîÔ∏è";
  }

  function repeatFunction() {
    if (blocking) {
      var playerElement = document.getElementById("player1");
      createWarning("üõ°Ô∏è", playerElement, 500);
    }

    setActionButtonsText();
  }

  function setActionButtonsText() {
    document.getElementById("topText").innerHTML =
      selCreature != null ? "^" : "^";
    document.getElementById("leftText").innerHTML =
      selCreature != null ? "Use" : "Use";
    //blockText.innerHTML = selCreature != null ? "üõ°Ô∏è" : "üõ°Ô∏è";
    document.getElementById("rightText").innerHTML =
      selCreature != null ? "Attack" : "Equip";
    document.getElementById("bottomText").innerHTML =
      selCreature != null ? "v" : "v";
  }
</script>

<script>
  /*
   * src="perlin.js"
   * A speed-improved perlin and simplex noise algorithms for 2D.
   *
   * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
   * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
   * Better rank ordering method by Stefan Gustavson in 2012.
   * Converted to Javascript by Joseph Gentle.
   *
   * Version 2012-03-09
   *
   * This code was placed in the public domain by its original author,
   * Stefan Gustavson. You may use it as you see fit, but
   * attribution is appreciated.
   *
   */

  (function (global) {
    var module = (global.noise = {});

    function Grad(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }

    Grad.prototype.dot2 = function (x, y) {
      return this.x * x + this.y * y;
    };

    Grad.prototype.dot3 = function (x, y, z) {
      return this.x * x + this.y * y + this.z * z;
    };

    var grad3 = [
      new Grad(1, 1, 0),
      new Grad(-1, 1, 0),
      new Grad(1, -1, 0),
      new Grad(-1, -1, 0),
      new Grad(1, 0, 1),
      new Grad(-1, 0, 1),
      new Grad(1, 0, -1),
      new Grad(-1, 0, -1),
      new Grad(0, 1, 1),
      new Grad(0, -1, 1),
      new Grad(0, 1, -1),
      new Grad(0, -1, -1),
    ];

    var p = [
      151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,
      140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247,
      120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
      33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165,
      71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211,
      133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25,
      63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
      135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
      226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206,
      59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248,
      152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,
      39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218,
      246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241,
      81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157,
      184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
      222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
    ];
    // To remove the need for index wrapping, double the permutation table length
    var perm = new Array(512);
    var gradP = new Array(512);

    // This isn't a very good seeding function, but it works ok. It supports 2^16
    // different seed values. Write something better if you need more seeds.
    module.seed = function (seed) {
      if (seed > 0 && seed < 1) {
        // Scale the seed out
        seed *= 65536;
      }

      seed = Math.floor(seed);
      if (seed < 256) {
        seed |= seed << 8;
      }

      for (var i = 0; i < 256; i++) {
        var v;
        if (i & 1) {
          v = p[i] ^ (seed & 255);
        } else {
          v = p[i] ^ ((seed >> 8) & 255);
        }

        perm[i] = perm[i + 256] = v;
        gradP[i] = gradP[i + 256] = grad3[v % 12];
      }
    };

    module.seed(0);

    /*
  for(var i=0; i<256; i++) {
    perm[i] = perm[i + 256] = p[i];
    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
  }*/

    // Skewing and unskewing factors for 2, 3, and 4 dimensions
    var F2 = 0.5 * (Math.sqrt(3) - 1);
    var G2 = (3 - Math.sqrt(3)) / 6;

    var F3 = 1 / 3;
    var G3 = 1 / 6;

    // 2D simplex noise
    module.simplex2 = function (xin, yin) {
      var n0, n1, n2; // Noise contributions from the three corners
      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin) * F2; // Hairy factor for 2D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var t = (i + j) * G2;
      var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
      var y0 = yin - j + t;
      // For the 2D case, the simplex shape is an equilateral triangle.
      // Determine which simplex we are in.
      var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
      if (x0 > y0) {
        // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        i1 = 1;
        j1 = 0;
      } else {
        // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        i1 = 0;
        j1 = 1;
      }
      // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
      // c = (3-sqrt(3))/6
      var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
      var y1 = y0 - j1 + G2;
      var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
      var y2 = y0 - 1 + 2 * G2;
      // Work out the hashed gradient indices of the three simplex corners
      i &= 255;
      j &= 255;
      var gi0 = gradP[i + perm[j]];
      var gi1 = gradP[i + i1 + perm[j + j1]];
      var gi2 = gradP[i + 1 + perm[j + 1]];
      // Calculate the contribution from the three corners
      var t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient
      }
      var t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * gi1.dot2(x1, y1);
      }
      var t2 = 0.5 - x2 * x2 - y2 * y2;
      if (t2 < 0) {
        n2 = 0;
      } else {
        t2 *= t2;
        n2 = t2 * t2 * gi2.dot2(x2, y2);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to return values in the interval [-1,1].
      return 70 * (n0 + n1 + n2);
    };

    // 3D simplex noise
    module.simplex3 = function (xin, yin, zin) {
      var n0, n1, n2, n3; // Noise contributions from the four corners

      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin + zin) * F3; // Hairy factor for 2D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var k = Math.floor(zin + s);

      var t = (i + j + k) * G3;
      var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
      var y0 = yin - j + t;
      var z0 = zin - k + t;

      // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
      // Determine which simplex we are in.
      var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
      var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        }
      } else {
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        }
      }
      // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
      // c = 1/6.
      var x1 = x0 - i1 + G3; // Offsets for second corner
      var y1 = y0 - j1 + G3;
      var z1 = z0 - k1 + G3;

      var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
      var y2 = y0 - j2 + 2 * G3;
      var z2 = z0 - k2 + 2 * G3;

      var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
      var y3 = y0 - 1 + 3 * G3;
      var z3 = z0 - 1 + 3 * G3;

      // Work out the hashed gradient indices of the four simplex corners
      i &= 255;
      j &= 255;
      k &= 255;
      var gi0 = gradP[i + perm[j + perm[k]]];
      var gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];
      var gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];
      var gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]];

      // Calculate the contribution from the four corners
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * gi0.dot3(x0, y0, z0); // (x,y) of grad3 used for 2D gradient
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t2 < 0) {
        n2 = 0;
      } else {
        t2 *= t2;
        n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0) {
        n3 = 0;
      } else {
        t3 *= t3;
        n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to return values in the interval [-1,1].
      return 32 * (n0 + n1 + n2 + n3);
    };

    // ##### Perlin noise stuff

    function fade(t) {
      return t * t * t * (t * (t * 6 - 15) + 10);
    }

    function lerp(a, b, t) {
      return (1 - t) * a + t * b;
    }

    // 2D Perlin Noise
    module.perlin2 = function (x, y) {
      // Find unit grid cell containing point
      var X = Math.floor(x),
        Y = Math.floor(y);
      // Get relative xy coordinates of point within that cell
      x = x - X;
      y = y - Y;
      // Wrap the integer cells at 255 (smaller integer period can be introduced here)
      X = X & 255;
      Y = Y & 255;

      // Calculate noise contributions from each of the four corners
      var n00 = gradP[X + perm[Y]].dot2(x, y);
      var n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);
      var n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);
      var n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);

      // Compute the fade curve value for x
      var u = fade(x);

      // Interpolate the four results
      return lerp(lerp(n00, n10, u), lerp(n01, n11, u), fade(y));
    };

    // 3D Perlin Noise
    module.perlin3 = function (x, y, z) {
      // Find unit grid cell containing point
      var X = Math.floor(x),
        Y = Math.floor(y),
        Z = Math.floor(z);
      // Get relative xyz coordinates of point within that cell
      x = x - X;
      y = y - Y;
      z = z - Z;
      // Wrap the integer cells at 255 (smaller integer period can be introduced here)
      X = X & 255;
      Y = Y & 255;
      Z = Z & 255;

      // Calculate noise contributions from each of the eight corners
      var n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);
      var n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);
      var n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);
      var n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);
      var n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);
      var n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);
      var n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);
      var n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(
        x - 1,
        y - 1,
        z - 1
      );

      // Compute the fade curve value for x, y, z
      var u = fade(x);
      var v = fade(y);
      var w = fade(z);

      // Interpolate
      return lerp(
        lerp(lerp(n000, n100, u), lerp(n001, n101, u), w),
        lerp(lerp(n010, n110, u), lerp(n011, n111, u), w),
        v
      );
    };
  })(this);
</script>
