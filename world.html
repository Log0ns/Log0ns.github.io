<html>
  <head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <script>
      var baseEnvJson = {};

      var shopInfo = {
        // TODO more shops
        ArmorShop: {
          shopType: "level",
          purchase: "clothArmor",
          cost: 2,
        },
        ItemShop: {
          shopType: "item",
          purchase: "key",
          cost: 3,
        },
      };

      var questInfo = {
        // TODO more quests
        Quest1: {
          name: "Quest 1",
          worldCoord: [101, 100],
          targetType: "creature",
          target: "Fox",
          amount: 2,
          reward: "key",
          rewardAmount: 2,
        },
        Quest2: {
          name: "Quest 2",
          worldCoord: [100, 101],
          targetType: "item",
          target: "experience",
          amount: 4,
          reward: "bow",
          rewardAmount: 4,
        },
      };

      var quests = [];

      var activeDungeon = -1;
      var saveWorldCoords = [];

      // TODO add dungeons
      var dungeonInfo = {
        Town: {
          id: 0,
          reqItem: "",
          worldCoord: [100, 100],
          size: 15,
          danger: 0,
          bossChance: 10,
          boss: {
            name: "King",
            symbol: "üëë",
            color: "#8B4513",
            health: 100,
          },
        },
        Dungeongrass: {
          id: 1,
          reqItem: "key",
          worldCoord: [101, 100],
          size: 15,
          danger: 2,
          bossChance: 10,
          boss: {
            name: "BossSpider",
            symbol: "üï∑üï∑üï∑",
            color: "#8B4513",
            health: 10,
          },
        },
      };

      var Town = {
        environment: {
          name: "Town",
          danger: 0,
          enemyCount: 6,
          worldSize: 15,
        },
        floor_tile: {
          name: "Cobblestone",
          symbol: "‚ñ†",
          backgroundColor: "#808080",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Market Stall",
            symbol: "‚ñ£",
            backgroundColor: "#FFD700",
            color: "#964B00",
            rarity: 0.5,
            smoothness: 25,
          },
          {
            name: "Tower",
            symbol: "‚ñ≤",
            backgroundColor: "#800080",
            color: "#FFD700",
            rarity: 0.93,
            smoothness: 30,
          },
          {
            name: "Fountain",
            symbol: "‚ôß",
            backgroundColor: "#00CED1",
            color: "#FFFFFF",
            rarity: 0.98,
            smoothness: 20,
          },
        ],
        creature_types: [
          {
            name: "Knight",
            symbol: "üõ°Ô∏è",
            color: "#C0C0C0",
            health: 20,
          },
          {
            name: "Wizard",
            symbol: "üßô",
            color: "#551A8B",
            health: 20,
          },
          {
            name: "Guard",
            symbol: "üó°Ô∏è",
            color: "#800000",
            health: 20,
          },
        ],
      };
      var Dungeongrass = {
        environment: {
          name: "Grass Dungeon",
          danger: 1,
          enemyCount: 2,
          worldSize: 15,
        },
        floor_tile: {
          name: "Mossy Ground",
          symbol: "‚ñ≤",
          backgroundColor: "#006400",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Vines",
            symbol: "‚âã",
            backgroundColor: "#228B22",
            color: "#FF0000",
            rarity: 0.2,
            smoothness: 50,
          },
          {
            name: "Spider Webs",
            symbol: "‚ò†",
            backgroundColor: "#D3D3D3",
            color: "#FF8C00",
            rarity: 0.9,
            smoothness: 10,
          },
          {
            name: "Mushrooms",
            symbol: "‚ô†",
            backgroundColor: "#A0522D",
            color: "#FFD700",
            rarity: 0.6,
            smoothness: 30,
            isHerb: true,
          },
        ],
        creature_types: [
          {
            name: "GiantSpider",
            symbol: "üï∑",
            color: "#8B4513",
            health: 3,
          },
          {
            name: "VenomousSnake",
            symbol: "üêç",
            color: "#32CD32",
            health: 3,
          },
          {
            name: "GrassGolem",
            symbol: "üåø",
            color: "#7CFC00",
            health: 3,
          },
        ],
      };

      var envJsons = [];

      var lavaCanyon = {
        environment: {
          name: "Lava Canyon",
          danger: 10,
          enemyCount: 2,
          worldSize: 15,
        },
        floor_tile: {
          name: "Rock", // ground
          symbol: "‚ñ≤",
          backgroundColor: "#8B4513",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Lava", // group
            symbol: "‚âã",
            backgroundColor: "#FF4C00",
            color: "#FFFF00",
            rarity: 0.5,
            smoothness: 10,
            isWater: true,
          },
          {
            name: "Tree", // individual
            symbol: "‚ô†",
            backgroundColor: "#006400",
            color: "#FFFF00",
            rarity: 0.9,
            smoothness: 10,
          },
          {
            name: "Bones", // rare
            symbol: "‚ò†",
            backgroundColor: "#D3D3D3",
            color: "#FF0000",
            rarity: 0.99,
            smoothness: 10,
          },
        ],
        creature_types: [
          {
            name: "Dragon",
            symbol: "üêâ",
            color: "#ffff99",
            health: 3,
          },
          {
            name: "Troll",
            symbol: "üëæ", // TODO
            color: "#ff5050",
            health: 3,
          },
          {
            name: "Golem",
            symbol: "üíé",
            color: "#ccff99",
            health: 3,
          },
        ],
      };

      var celestialRealm = {
        environment: {
          name: "Celestial Realm",
          danger: 10,
          enemyCount: 6,
          worldSize: 15,
        },
        floor_tile: {
          name: "Starlight",
          symbol: "‚ú¶",
          backgroundColor: "#000000",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Clouds",
            symbol: "‚òÅ",
            backgroundColor: "#FFFFFF",
            color: "#CCCCCC",
            rarity: 0.2,
            smoothness: 50,
          },
          {
            name: "Feathers",
            symbol: "‚úø",
            backgroundColor: "#FFC0CB",
            color: "#FFFF00",
            rarity: 0.9,
            smoothness: 20,
          },
          {
            name: "Crystal",
            symbol: "‚ùñ",
            backgroundColor: "#87CEEB",
            color: "#FFFFFF",
            rarity: 0.5,
            smoothness: 30,
            isOre: true,
          },
        ],
        creature_types: [
          {
            name: "Seraph",
            symbol: "üëº",
            color: "#FFD700",
            health: 3,
          },
          {
            name: "CelestialDragon",
            symbol: "üêâ",
            color: "#00CED1",
            health: 3,
          },
          {
            name: "AstralUnicorn",
            symbol: "ü¶Ñ",
            color: "#FF69B4",
            health: 3,
          },
        ],
      };

      var enchantedForest = {
        environment: {
          name: "Enchanted Forest",
          danger: 8,
          enemyCount: 3,
          worldSize: 15,
        },
        floor_tile: {
          name: "Moss",
          symbol: "‚ñ≤",
          backgroundColor: "#228B22",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Glowing Water",
            symbol: "‚âã",
            backgroundColor: "#8A2BE2",
            color: "#FFFF00",
            rarity: 0.6,
            smoothness: 25,
            isWater: true,
          },
          {
            name: "Ancient Trees",
            symbol: "‚ô†",
            backgroundColor: "#006400",
            color: "#FFD700",
            rarity: 0.5,
            smoothness: 30,
          },
          {
            name: "Magic Crystals",
            symbol: "‚ò†",
            backgroundColor: "#FF1493",
            color: "#00FFFF",
            rarity: 0.9,
            smoothness: 15,
            isOre: true,
          },
        ],
        creature_types: [
          {
            name: "Fairy",
            symbol: "üßö",
            color: "#FF69B4",
            health: 3,
          },
          {
            name: "Elf",
            symbol: "üßù",
            color: "#008080",
            health: 3,
          },
          {
            name: "Goblin",
            symbol: "üë∫",
            color: "#FFA500",
            health: 3,
          },
        ],
      };

      var lavaFortress = {
        environment: {
          name: "Lava Fortress",
          danger: 10,
          enemyCount: 4,
          worldSize: 15,
        },
        floor_tile: {
          name: "Lava Rock",
          symbol: "‚ñ≤",
          backgroundColor: "#800000",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Lava",
            symbol: "‚âã",
            backgroundColor: "#FF4500",
            color: "#FFD700",
            rarity: 0.2,
            smoothness: 50,
            isWater: true,
          },
          {
            name: "Volcanic Crater",
            symbol: "‚ô†",
            backgroundColor: "#8B0000",
            color: "#FF4500",
            rarity: 0.4,
            smoothness: 40,
          },
          {
            name: "Bones",
            symbol: "‚ò†",
            backgroundColor: "#D3D3D3",
            color: "#FF0000",
            rarity: 0.999,
            smoothness: 5,
          },
        ],
        creature_types: [
          {
            name: "FireElemental",
            symbol: "üúÑ",
            color: "#FF4500",
            health: 3,
          },
          {
            name: "MagmaBeast",
            symbol: "üúÅ",
            color: "#FF8C00",
            health: 3,
          },
          {
            name: "LavaGolem",
            symbol: "üúÉ",
            color: "#FF0000",
            health: 3,
          },
        ],
      };

      var crystalCaverns = {
        environment: {
          name: "Crystal Caverns",
          danger: 6,
          enemyCount: 3,
          worldSize: 15,
        },
        floor_tile: {
          name: "Crystals",
          symbol: "‚ñ≤",
          backgroundColor: "#00CED1",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Stalactites",
            symbol: "‚âã",
            backgroundColor: "#808080",
            color: "#FFD700",
            rarity: 0.2,
            smoothness: 35,
          },
          {
            name: "Glowing Mushrooms",
            symbol: "‚ô†",
            backgroundColor: "#00FF00",
            color: "#8A2BE2",
            rarity: 0.9,
            smoothness: 15,
            isHerb: true,
          },
          {
            name: "Crystal Skulls",
            symbol: "‚ò†",
            backgroundColor: "#C0C0C0",
            color: "#FF1493",
            rarity: 0.999,
            smoothness: 10,
            isOre: true,
          },
        ],
        creature_types: [
          {
            name: "CrystalGolem",
            symbol: "üíé",
            color: "#00BFFF",
            health: 3,
          },
          {
            name: "LuminousSerpent",
            symbol: "üêç",
            color: "#00FF00",
            health: 3,
          },
          {
            name: "SpectralSpider",
            symbol: "üï∑",
            color: "#9400D3",
            health: 3,
          },
        ],
      };

      var mistyMoorlands = {
        environment: {
          name: "Misty Moorlands",
          danger: 4,
          enemyCount: 2,
          worldSize: 15,
        },
        floor_tile: {
          name: "Moor",
          symbol: "‚ñ≤",
          backgroundColor: "#B0C4DE",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Mist",
            symbol: "‚âã",
            backgroundColor: "#D3D3D3",
            color: "#7B68EE",
            rarity: 0.5,
            smoothness: 25,
          },
          {
            name: "Ancient Ruins",
            symbol: "‚ò†",
            backgroundColor: "#8B0000",
            color: "#FFD700",
            rarity: 0.99,
            smoothness: 8,
          },
          {
            name: "Dead Tree",
            symbol: "‚ô†",
            backgroundColor: "#A0522D",
            color: "#696969",
            rarity: 0.9,
            smoothness: 15,
            isHerb: true,
          },
        ],
        creature_types: [
          {
            name: "Ghost",
            symbol: "üëª",
            color: "#F8F8FF",
            health: 3,
          },
          {
            name: "Werewolf",
            symbol: "üê∫",
            color: "#483D8B",
            health: 3,
          },
          {
            name: "Wisp",
            symbol: "üßö",
            color: "#FFD700",
            health: 3,
          },
        ],
      };

      var whisperingWoods = {
        environment: {
          name: "Whispering Woods",
          danger: 6,
          enemyCount: 3,
          worldSize: 15,
        },
        floor_tile: {
          name: "Grassy Ground",
          symbol: "‚ñ≤",
          backgroundColor: "#7CCD7C",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Whispering Tree",
            symbol: "‚ô†",
            backgroundColor: "#D8BFD8",
            color: "#228B22",
            rarity: 0.5,
            smoothness: 30,
          },
          {
            name: "Glowing Fireflies",
            symbol: "‚ò†",
            backgroundColor: "#ADD8E6",
            color: "#FF1493",
            rarity: 0.9,
            smoothness: 10,
          },
          {
            name: "Mushrooms",
            symbol: "‚ô†",
            backgroundColor: "#FF4500",
            color: "#FFD700",
            rarity: 0.7,
            smoothness: 20,
            isHerb: true,
          },
        ],
        creature_types: [
          {
            name: "Elk",
            symbol: "ü¶å",
            color: "#8B4513",
            health: 3,
          },
          {
            name: "Owl",
            symbol: "ü¶â",
            color: "#663399",
            health: 3,
          },
          {
            name: "Fairy",
            symbol: "üßö‚Äç‚ôÄÔ∏è",
            color: "#FF69B4",
            health: 3,
          },
        ],
      };

      var timelessDesert = {
        environment: {
          name: "Timeless Desert",
          danger: 8,
          enemyCount: 1,
          worldSize: 15,
        },
        floor_tile: {
          name: "Sand",
          symbol: "‚ñ≤",
          backgroundColor: "#F0E68C",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Cacti",
            symbol: "‚âã",
            backgroundColor: "#006400",
            color: "#FFD700",
            rarity: 0.5,
            smoothness: 30,
          },
          {
            name: "Ancient Ruins",
            symbol: "‚ò†",
            backgroundColor: "#D2B48C",
            color: "#A0522D",
            rarity: 0.99,
            smoothness: 5,
          },
          {
            name: "Desert Flower",
            symbol: "‚ô†",
            backgroundColor: "#20B2AA",
            color: "#00FFFF",
            rarity: 0.9,
            smoothness: 10,
            isHerb: true,
          },
        ],
        creature_types: [
          {
            name: "Scorpion",
            symbol: "ü¶Ç",
            color: "#8B4513",
            health: 3,
          },
          {
            name: "Vulture",
            symbol: "ü¶Ö",
            color: "#800000",
            health: 3,
          },
          {
            name: "Camel",
            symbol: "üê´",
            color: "#CD853F",
            health: 3,
          },
        ],
      };

      var frozenTundra = {
        environment: {
          name: "Frozen Tundra",
          danger: 3,
          enemyCount: 2,
          worldSize: 15,
        },
        floor_tile: {
          name: "Snow",
          symbol: "‚ñ≤",
          backgroundColor: "#F0F8FF",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Icicles",
            symbol: "‚âã",
            backgroundColor: "#00BFFF",
            color: "#FFFFFF",
            rarity: 0.4,
            smoothness: 30,
          },
          {
            name: "Pine Tree",
            symbol: "‚ô†",
            backgroundColor: "#2E8B57",
            color: "#FFD700",
            rarity: 0.8,
            smoothness: 25,
          },
          {
            name: "Frozen Bones",
            symbol: "‚ò†",
            backgroundColor: "#D3D3D3",
            color: "#00FFFF",
            rarity: 0.99,
            smoothness: 10,
          },
        ],
        creature_types: [
          {
            name: "SnowYeti",
            symbol: "üóø",
            color: "#E0FFFF",
            health: 3,
          },
          {
            name: "IceDragon",
            symbol: "üêâ",
            color: "#B0E0E6",
            health: 3,
          },
          {
            name: "FrostWraith",
            symbol: "üëª",
            color: "#ADD8E6",
            health: 3,
          },
        ],
      };

      var heartland = {
        environment: {
          name: "Heartland",
          danger: 1,
          enemyCount: 1,
          worldSize: 15,
        },
        floor_tile: {
          name: "Grass",
          symbol: "‚ñ≤",
          backgroundColor: "#5A864F",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Water",
            symbol: "‚âã",
            backgroundColor: "#42E5F4",
            color: "#EEEEFF",
            rarity: 0.4,
            smoothness: 10,
            isWater: true,
          },
          {
            name: "Tree",
            symbol: "‚ô†",
            backgroundColor: "#228B22",
            color: "#FFFFFF",
            rarity: 0.7,
            smoothness: 20,
          },
          {
            name: "Mushroom",
            symbol: "‚ô£",
            backgroundColor: "#964B00",
            color: "#FFD700",
            rarity: 0.95,
            smoothness: 10,
            isHerb: true,
          },
        ],
        creature_types: [
          {
            name: "Owl",
            symbol: "ü¶â",
            color: "#704214",
            health: 3,
          },
          {
            name: "Fox",
            symbol: "ü¶ä",
            color: "#FF4500",
            health: 3,
          },
          {
            name: "Squirrel",
            symbol: "üêøÔ∏è",
            color: "#A0522D",
            health: 3,
          },
        ],
      };

      var luminousGlades = {
        environment: {
          name: "Luminous Glades",
          danger: 2,
          enemyCount: 2,
          worldSize: 15,
        },
        floor_tile: {
          name: "Glowing Moss",
          symbol: "‚ñ≤",
          backgroundColor: "#00FF00",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Floating Water",
            symbol: "‚¶ø",
            backgroundColor: "#FFD700",
            color: "#800080",
            rarity: 0.4,
            smoothness: 25,
            isWater: true,
          },
          {
            name: "Luminous Trees",
            symbol: "‚ô†",
            backgroundColor: "#008000",
            color: "#FFFF00",
            rarity: 0.5,
            smoothness: 30,
          },
          {
            name: "Glowing Flowers",
            symbol: "‚ùÄ",
            backgroundColor: "#FF69B4",
            color: "#00FFFF",
            rarity: 0.85,
            smoothness: 15,
            isHerb: true,
          },
        ],
        creature_types: [
          {
            name: "Glowbug",
            symbol: "üêû",
            color: "#FFD700",
            health: 3,
          },
          {
            name: "Will-o'-the-Wisp",
            symbol: "üî•",
            color: "#FF4500",
            health: 3,
          },
          {
            name: "Spirit Fox",
            symbol: "ü¶ä",
            color: "#00FF00",
            health: 3,
          },
        ],
      };

      var floatingIslands = {
        environment: {
          name: "Floating Islands",
          danger: 5,
          enemyCount: 3,
          worldSize: 15,
        },
        floor_tile: {
          name: "Sky",
          symbol: "‚òÅ",
          backgroundColor: "#B0E2FF",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Floating Rock",
            symbol: "‚¶ø",
            backgroundColor: "#A9A9A9",
            color: "#808080",
            rarity: 0.3,
            smoothness: 30,
          },
          {
            name: "Waterfall",
            symbol: "‚âã",
            backgroundColor: "#1E90FF",
            color: "#ADD8E6",
            rarity: 0.9,
            smoothness: 15,
            isWater: true,
          },
          {
            name: "Glowing Crystal",
            symbol: "‚ô¶",
            backgroundColor: "#E6E6FA",
            color: "#FFD700",
            rarity: 0.2,
            smoothness: 40,
            isOre: true,
          },
        ],
        creature_types: [
          {
            name: "SkySerpent",
            symbol: "üêâ",
            color: "#9932CC",
            health: 3,
          },
          {
            name: "WingedLion",
            symbol: "ü¶Å",
            color: "#FFA500",
            health: 3,
          },
          {
            name: "CloudElemental",
            symbol: "üå©Ô∏è",
            color: "#FFFFFF",
            health: 3,
          },
        ],
      };

      var rockyHighlands = {
        environment: {
          name: "Rocky Highlands",
          danger: 6,
          enemyCount: 3,
          worldSize: 15,
        },
        floor_tile: {
          name: "Rock",
          symbol: "‚ñ≤",
          backgroundColor: "#A9A9A9",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Pine Trees",
            symbol: "‚ô†",
            backgroundColor: "#006400",
            color: "#228B22",
            rarity: 0.7,
            smoothness: 30,
          },
          {
            name: "Brush",
            symbol: "‚âã",
            backgroundColor: "#F0E68C",
            color: "#8B4513",
            rarity: 0.9,
            smoothness: 15,
          },
          {
            name: "Boulder",
            symbol: "‚¶ø",
            backgroundColor: "#808080",
            color: "#FFA500",
            rarity: 0.3,
            smoothness: 40,
            isOre: true,
          },
        ],
        creature_types: [
          {
            name: "Eagle",
            symbol: "ü¶Ö",
            color: "#FFD700",
            health: 3,
          },
          {
            name: "MountainLion",
            symbol: "ü¶Å",
            color: "#FF8C00",
            health: 3,
          },
          {
            name: "Bobcat",
            symbol: "üò∫",
            color: "#A52A2A",
            health: 3,
          },
        ],
      };

      var mysticCaverns = {
        environment: {
          name: "Mystic Cavern",
          danger: 4,
          enemyCount: 4,
          worldSize: 15,
        },
        floor_tile: {
          name: "Stone",
          symbol: "‚ñ≤",
          backgroundColor: "#808080",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Glowing Water",
            symbol: "‚âã",
            backgroundColor: "#00FFFF",
            color: "#FFFFFF",
            rarity: 0.5,
            smoothness: 30,
            isWater: true,
          },
          {
            name: "Ancient Runes",
            symbol: "‚ô†",
            backgroundColor: "#A020F0",
            color: "#FFFF00",
            rarity: 0.8,
            smoothness: 20,
          },
          {
            name: "Fossilized Bones",
            symbol: "‚ò†",
            backgroundColor: "#D2B48C",
            color: "#FF0000",
            rarity: 0.999,
            smoothness: 10,
          },
        ],
        creature_types: [
          {
            name: "Wisp",
            symbol: "üåü",
            color: "#FFD700",
            health: 3,
          },
          {
            name: "ShadowBeast",
            symbol: "üëª",
            color: "#7B68EE",
            health: 3,
          },
          {
            name: "CrystalElemental",
            symbol: "üíé",
            color: "#00CED1",
            health: 3,
          },
        ],
      };

      var elementalWasteland = {
        environment: {
          name: "Elemental Wasteland",
          danger: 7,
          enemyCount: 3,
          worldSize: 15,
        },
        floor_tile: {
          name: "Cracked Earth",
          symbol: "‚ñ≤",
          backgroundColor: "#7F5230",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Burning Water",
            symbol: "‚âã",
            backgroundColor: "#FF4500",
            color: "#FFD700",
            rarity: 0.2,
            smoothness: 35,
            isWater: true,
          },
          {
            name: "Twisted Trees",
            symbol: "‚ô†",
            backgroundColor: "#8B4513",
            color: "#FFA500",
            rarity: 0.8,
            smoothness: 15,
          },
          {
            name: "Ancient Relics",
            symbol: "‚ò†",
            backgroundColor: "#DAA520",
            color: "#C0C0C0",
            rarity: 0.999,
            smoothness: 5,
          },
        ],
        creature_types: [
          {
            name: "EmberElemental",
            symbol: "üî•",
            color: "#FF4500",
            health: 3,
          },
          {
            name: "EarthGolem",
            symbol: "üóø",
            color: "#8B4513",
            health: 3,
          },
          {
            name: "AbyssalShadow",
            symbol: "üåë",
            color: "#000000",
            health: 3,
          },
        ],
      };

      var underwaterCity = {
        environment: {
          name: "Underwater City",
          danger: 10,
          enemyCount: 6,
          worldSize: 15,
        },
        floor_tile: {
          name: "Seabed",
          symbol: "‚ñ≤",
          backgroundColor: "#008080",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Dark Water",
            symbol: "‚âã",
            backgroundColor: "#FF4500",
            color: "#FFD700",
            rarity: 0.2,
            smoothness: 40,
            isWater: true,
          },
          {
            name: "Kelp Forest",
            symbol: "‚ô†",
            backgroundColor: "#006400",
            color: "#00FF00",
            rarity: 0.6,
            smoothness: 30,
            isHerb: true,
          },
          {
            name: "Sunken Ship",
            symbol: "‚ò†",
            backgroundColor: "#A9A9A9",
            color: "#FF8C00",
            rarity: 0.9,
            smoothness: 25,
          },
        ],
        creature_types: [
          {
            name: "Shark",
            symbol: "ü¶à",
            color: "#0000CD",
            health: 3,
          },
          {
            name: "Octopus",
            symbol: "üêô",
            color: "#8A2BE2",
            health: 3,
          },
          {
            name: "Mermaid",
            symbol: "üßú‚Äç‚ôÄÔ∏è",
            color: "#00BFFF",
            health: 3,
          },
        ],
      };

      var ancientRuins = {
        environment: {
          name: "Ancient Ruins",
          danger: 7,
          enemyCount: 3,
          worldSize: 15,
        },
        floor_tile: {
          name: "Mossy Stone",
          symbol: "‚ñ≤",
          backgroundColor: "#5C6E3A",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Cracked Pillars",
            symbol: "‚àû",
            backgroundColor: "#6D6E5A",
            color: "#D9D9D9",
            rarity: 0.2,
            smoothness: 45,
          },
          {
            name: "Broken Statues",
            symbol: "‚ò•",
            backgroundColor: "#6D6E5A",
            color: "#DAA520",
            rarity: 0.9,
            smoothness: 20,
          },
          {
            name: "Ancient Vines",
            symbol: "‚àû",
            backgroundColor: "#317F43",
            color: "#7FFF00",
            rarity: 0.4,
            smoothness: 35,
            isHerb: true,
          },
        ],
        creature_types: [
          {
            name: "Guardian",
            symbol: "üóø",
            color: "#808080",
            health: 3,
          },
          {
            name: "Spirit",
            symbol: "üëª",
            color: "#7B68EE",
            health: 3,
          },
          {
            name: "Shadow",
            symbol: "üåë",
            color: "#696969",
            health: 3,
          },
        ],
      };

      var whisperingSands = {
        environment: {
          name: "Whispering Sands",
          danger: 10,
          enemyCount: 4,
          worldSize: 15,
        },
        floor_tile: {
          name: "Sand",
          symbol: "‚ñ≤",
          backgroundColor: "#FFE4B5",
          color: "#FFFFFF",
          canWalk: true,
        },
        prop_types: [
          {
            name: "Wild Sand",
            symbol: "‚âã",
            backgroundColor: "#8B0000",
            color: "#FFD700",
            rarity: 0.5,
            smoothness: 15,
          },
          {
            name: "Palm Tree",
            symbol: "‚ô†",
            backgroundColor: "#006400",
            color: "#FFFF00",
            rarity: 0.8,
            smoothness: 20,
          },
          {
            name: "Skull Flower",
            symbol: "‚ò†",
            backgroundColor: "#D3D3D3",
            color: "#FF4500",
            rarity: 0.95,
            smoothness: 10,
            isHerb: true,
          },
        ],
        creature_types: [
          {
            name: "SandSerpent",
            symbol: "üêç",
            color: "#CD853F",
            health: 3,
          },
          {
            name: "Scorpion",
            symbol: "ü¶Ç",
            color: "#800000",
            health: 3,
          },
          {
            name: "DesertRat",
            symbol: "üêÄ",
            color: "#DAA520",
            health: 3,
          },
        ],
      };

      var darkAbyss = {
        environment: {
          name: "Dark Abyss",
          danger: 10,
          enemyCount: 4,
          worldSize: 15,
        },
        floor_tile: {
          name: "Seaweed",
          symbol: "œü",
          backgroundColor: "#000080",
          color: "#FFFFFF",
          canWalk: false,
        },
        prop_types: [
          {
            name: "Odd Water",
            symbol: "‚âà",
            backgroundColor: "#008000",
            color: "#00FFFF",
            rarity: 0.2,
            smoothness: 40,
            isWater: true,
          },
          {
            name: "Darkrock",
            symbol: "‚ò†",
            backgroundColor: "#1E90FF",
            color: "#FFFF00",
            rarity: 0.6,
            smoothness: 30,
          },
          {
            name: "Lightstone",
            symbol: "‚ú¶",
            backgroundColor: "#483D8B",
            color: "#FF1493",
            rarity: 0.999,
            smoothness: 5,
            isOre: true,
          },
        ],
        creature_types: [
          {
            name: "GiantSquid",
            symbol: "ü¶ë",
            color: "#FF4500",
            health: 3,
          },
          {
            name: "GhostShark",
            symbol: "üëª",
            color: "#FFD700",
            health: 3,
          },
          {
            name: "Monster",
            symbol: "ü¶Ç",
            color: "#00CED1",
            health: 15,
          },
        ],
      };

      // stats -- type, range, damage, health, attackSpeed, statEff, symbol
      var itemsJson = {
        fists: {
          type: "weapon",
          range: 1,
          damage: 3,
          health: 0,
          attackSpeed: 1,
          statEff: { stat: "none", amount: 0 },
          symbol: "‚öîÔ∏è",
          breakChance: 0,
        },
        rags: {
          type: "armor",
          range: 1,
          damage: 0,
          health: 1,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üõ°Ô∏è",
        },
        grass: {
          type: "item",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üóùÔ∏è",
        },
        water: {
          type: "potion",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üß™",
        },
        knife: {
          type: "weapon",
          range: 1,
          damage: 3,
          health: 0,
          attackSpeed: 2,
          statEff: { stat: "none", amount: 0 },
          symbol: "üó°Ô∏è",
          breakChance: 5,
        },
        sword: {
          type: "weapon",
          range: 3,
          damage: 4,
          health: 0,
          attackSpeed: 1,
          statEff: { stat: "none", amount: 0 },
          symbol: "‚öîÔ∏è",
          breakChance: 10,
        },
        axe: {
          type: "weapon",
          range: 2,
          damage: 6,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "‚öîÔ∏è",
          breakChance: 5,
        },
        spear: {
          type: "weapon",
          range: 4,
          damage: 3,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "‚öîÔ∏è",
          breakChance: 15,
        },
        bow: {
          type: "weapon",
          range: 8,
          damage: 2,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üèπ",
          breakChance: 15,
        },
        wand: {
          type: "weapon",
          range: 8,
          damage: 2,
          health: 5,
          attackSpeed: 1,
          statEff: { stat: "none", amount: 0 },
          symbol: "üîÆ",
          breakChance: 10,
        },
        clothArmor: {
          type: "armor",
          range: 1,
          damage: 0,
          health: 1,
          attackSpeed: 1,
          statEff: { stat: "none", amount: 0 },
          symbol: "üõ°Ô∏è",
        },
        ironArmor: {
          type: "armor",
          range: 0,
          damage: 0,
          health: 3,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üõ°Ô∏è",
        },
        damagePotion: {
          type: "potion",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "damage", amount: 3 },
          symbol: "üß™",
        },
        healthPotion: {
          type: "potion",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "health", amount: 10 },
          symbol: "üß™",
        },
        attackRangePotion: {
          type: "potion",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "attackRange", amount: 4 },
          symbol: "üß™",
        },
        attackSpeedPotion: {
          type: "potion",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "attackSpeed", amount: 2 },
          symbol: "üß™",
        },
        // TODO dungeon keys
        key: {
          type: "item",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üóùÔ∏è",
        },
        damageBuff: {
          type: "item",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üìú",
        },
        healthBuff: {
          type: "item",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üìú",
        },
        attackRangeBuff: {
          type: "item",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üìú",
        },
        attackSpeedBuff: {
          type: "item",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "üìú",
        },
        experience: {
          type: "item",
          range: 0,
          damage: 0,
          health: 0,
          attackSpeed: 0,
          statEff: { stat: "none", amount: 0 },
          symbol: "‚ú®",
        },
      };

      var knifeLevel = 1;
      var swordLevel = 1;
      var axeLevel = 1;
      var spearLevel = 1;
      var bowLevel = 1;
      var wandLevel = 1;
      var clothArmorLevel = 1;
      var ironArmorLevel = 1;
      var damagePotionLevel = 1;
      var healthPotionLevel = 1;
      var attackSpeedPotionLevel = 1;
      var attackRangePotionLevel = 1;

      var creatureJSON = {};

      var seed = 0; // TODO
      var worldSize = 15;
      var worldData = [];
      var worldTable;
      var creaturesParent;
      var createTimestamp;

      // Reset after 100
      var numCreatures = 0;
      var numEffects = 0;
      var numWarnings = 0;

      var blocking = false;
      var walkSpeed = 0.9;
      var workSpeed = 1000;
      var selTile;
      var selCreature;
      var firstArea = true;
      var areaCollections = 0;
      var defaultSmoothness = 15; // TODO noise scale

      var menuId = 0;

      document.addEventListener("keydown", function (event) {
        if (event.key === "ArrowDown") {
          arrowDown();
        }
        if (event.key === "ArrowUp") {
          arrowUp();
        }
        if (event.key === "ArrowLeft") {
          arrowLeft();
        }
        if (event.key === "ArrowRight") {
          arrowRight();
        }
        if (event.key === "q") {
          arrowUpLeft();
        }
        if (event.key === "e") {
          arrowUpRight();
        }
        if (event.key === "w") {
          arrowUp();
        }
        if (event.key === "a") {
          arrowLeft();
        }
        if (event.key === "s") {
          arrowDown();
        }
        if (event.key === "d") {
          arrowRight();
        }
        if (event.key === "z") {
          arrowDownLeft();
        }
        if (event.key === "c") {
          arrowDownRight();
        }
        if (event.key === "Enter") {
          enter();
        }
        if (event.key === " ") {
          enter();
        }
      });

      function arrowDown() {
        bottomCooldown(500);
      }
      function arrowDownLeft() {
        var shopJson = shopInfo[getPlayerTile().type.name];
        var questJson = questInfo[getPlayerTile().type.name];
        var dungeonJson = dungeonInfo[getPlayerTile().type.name];
        if (shopJson) {
          var playerElement = document.getElementById("player1");
          var ret =
            "type: " + (shopJson.shopType == "level" ? "level up" : "purchase");
          ret +=
            "<br>" +
            shopJson.purchase +
            " (" +
            (shopJson.shopType == "level"
              ? getStatTypeLevel(shopJson.purchase) *
                getStatTypeLevel(shopJson.purchase)
              : shopJson.cost) +
            " exp)";
          createWarning(ret, playerElement, 1500);
        } else if (questJson) {
          var playerElement = document.getElementById("player1");
          var ret =
            questJson.name +
            "<br>" +
            questJson.target +
            " (" +
            questJson.amount +
            ")" +
            "<br>" +
            "reward: " +
            questJson.reward +
            " (" +
            questJson.rewardAmount +
            ")";
          createWarning(ret, playerElement, 1500);
        } else if (dungeonJson) {
          var playerElement = document.getElementById("player1");
          var ret =
            "requires " +
            dungeonJson.reqItem +
            "<br>" +
            "lvl: " +
            dungeonJson.danger;
          createWarning(ret, playerElement, 1500);
        } else {
          var playerElement = document.getElementById("player1");
          var ret = getPlayerTile().type.name;
          createWarning(ret, playerElement, 1500);
        }
      }
      function arrowDownRight() {
        clearSel();
      }
      function arrowUp() {
        topCooldown(500);
      }
      function arrowUpLeft() {
        useItem(equippedItem);
      }
      function arrowUpRight() {
        useItem(equippedPotion);
      }
      function arrowLeft() {
        leftCooldown(500);
      }
      function arrowRight() {
        rightCooldown(2000);
      }
      function enter() {
        centerCooldown(200);
      }

      var worldMap = [];
      var worldMapSize = 200; // must be divisible by 5
      var worldCoords = [0, 0];

      function getCurEnvJsonId() {
        if (activeDungeon >= 0) {
          if (activeDungeon == 0) {
            return 19;
          } else {
            return 0;
          }
          // TODO add dungeons
        }

        if (
          worldCoords[0] < (worldMapSize / 5) * 1 &&
          worldCoords[1] < (worldMapSize / 5) * 1
        ) {
          return 16;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 1 &&
          worldCoords[1] < (worldMapSize / 5) * 2
        ) {
          return 12;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 1 &&
          worldCoords[1] < (worldMapSize / 5) * 3
        ) {
          return 7;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 1 &&
          worldCoords[1] < (worldMapSize / 5) * 4
        ) {
          return 4;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 1 &&
          worldCoords[1] < (worldMapSize / 5) * 5
        ) {
          return 1;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 2 &&
          worldCoords[1] < (worldMapSize / 5) * 1
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 2 &&
          worldCoords[1] < (worldMapSize / 5) * 2
        ) {
          return 13;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 2 &&
          worldCoords[1] < (worldMapSize / 5) * 3
        ) {
          return 8;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 2 &&
          worldCoords[1] < (worldMapSize / 5) * 4
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 2 &&
          worldCoords[1] < (worldMapSize / 5) * 5
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 3 &&
          worldCoords[1] < (worldMapSize / 5) * 1
        ) {
          return 17;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 3 &&
          worldCoords[1] < (worldMapSize / 5) * 2
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 3 &&
          worldCoords[1] < (worldMapSize / 5) * 3
        ) {
          return 9;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 3 &&
          worldCoords[1] < (worldMapSize / 5) * 4
        ) {
          return 5;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 3 &&
          worldCoords[1] < (worldMapSize / 5) * 5
        ) {
          return 2;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 4 &&
          worldCoords[1] < (worldMapSize / 5) * 1
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 4 &&
          worldCoords[1] < (worldMapSize / 5) * 2
        ) {
          return 14;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 4 &&
          worldCoords[1] < (worldMapSize / 5) * 3
        ) {
          return 10;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 4 &&
          worldCoords[1] < (worldMapSize / 5) * 4
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 4 &&
          worldCoords[1] < (worldMapSize / 5) * 5
        ) {
          return 0;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 5 &&
          worldCoords[1] < (worldMapSize / 5) * 1
        ) {
          return 18;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 5 &&
          worldCoords[1] < (worldMapSize / 5) * 2
        ) {
          return 15;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 5 &&
          worldCoords[1] < (worldMapSize / 5) * 3
        ) {
          return 11;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 5 &&
          worldCoords[1] < (worldMapSize / 5) * 4
        ) {
          return 6;
        } else if (
          worldCoords[0] < (worldMapSize / 5) * 5 &&
          worldCoords[1] < (worldMapSize / 5) * 5
        ) {
          return 3;
        } else {
          return 0;
        }
      }

      var health = 10;
      var equippedWeapon = "";
      var equippedArmor = "";
      var equippedItem = "";
      var equippedPotion = "";
      var items = [];

      function getEquippedWeapon() {
        return itemsJson[equippedWeapon != "" ? equippedWeapon : "fists"];
      }
      function getEquippedArmor() {
        return itemsJson[equippedArmor != "" ? equippedArmor : "rags"];
      }
      function getEquippedItem() {
        return itemsJson[equippedItem != "" ? equippedItem : "grass"];
      }
      function getEquippedPotion() {
        return itemsJson[equippedPotion != "" ? equippedPotion : "water"];
      }
      function isEquipped(item) {
        return (
          equippedWeapon == item ||
          equippedArmor == item ||
          equippedItem == item ||
          equippedPotion == item
        );
      }
      function updateStats() {
        var itemsDiv = document.getElementById("itemsDiv");
        itemsDiv.innerHTML =
          "Weapon: " + (equippedWeapon != "" ? equippedWeapon : "fists");
        itemsDiv.innerHTML +=
          "<br>" +
          "Equipment: " +
          (equippedArmor != "" ? equippedArmor : "rags");
        itemsDiv.innerHTML +=
          "<br>" + "Item: " + (equippedItem != "" ? equippedItem : "grass");
        itemsDiv.innerHTML +=
          "<br>" +
          "Potion: " +
          (equippedPotion != "" ? equippedPotion : "water");

        var sT =
          "Health: " +
          health +
          " / " +
          (10 + getStat("health", true)) +
          " (x" +
          getStatTypeLevel(equippedArmor) +
          ")";
        sT +=
          "<br>Damage: " +
          getStat("damage", false) +
          " (x" +
          getStatTypeLevel(equippedWeapon) +
          ")";
        sT += "<br>Speed: " + getStat("attackSpeed", false);
        sT += "<br>Range: " + getStat("attackRange", false) + " tiles";
        sT += "<br><br>Skills:";
        sT += "<br>Knife: " + knifeLevel;
        sT += "<br>Sword: " + swordLevel;
        sT += "<br>Axe: " + axeLevel;
        sT += "<br>Spear: " + spearLevel;
        sT += "<br>Bow: " + bowLevel;
        sT += "<br>Wand: " + wandLevel;
        sT += "<br>Cloth Armor: " + clothArmorLevel;
        sT += "<br>Iron Armor: " + ironArmorLevel;
        sT += "<br>Damage Potion: " + damagePotionLevel;
        sT += "<br>Health Potion: " + healthPotionLevel;
        sT += "<br>Speed Potion: " + attackSpeedPotionLevel;
        sT += "<br>Range Potion: " + attackRangePotionLevel;
        document.getElementById("statsDiv").innerHTML = sT;

        updateInfoText();
      }

      function getCreatureDrop(creature) {
        if (creature.id.startsWith("BossSpider")) {
          return "grass";
        } else {
          return getItemDrop();
        }
      }
      function getItemDrop() {
        if (baseEnvJson.environment.danger < 1) {
          return "";
        }

        if (
          getItemAmount("knife") < 1 &&
          getItemAmount("sword") < 1 &&
          getItemAmount("axe") < 1 &&
          getItemAmount("spear") < 1 &&
          getItemAmount("bow") < 1 &&
          getItemAmount("wand") < 1
        ) {
          var ranVal = randomRange(0, 5);
          if (ranVal == 0) {
            return "knife";
          } else if (ranVal == 1) {
            return "sword";
          } else if (ranVal == 2) {
            return "axe";
          } else if (ranVal == 3) {
            return "spear";
          } else if (ranVal == 4) {
            return "bow";
          } else if (ranVal == 5) {
            return "wand";
          }
        } else {
          var ranVal = randomRange(0, 24);
          if (ranVal == 0) {
            return "experience"; // TODO leveling and shops
          } else if (ranVal == 1) {
            return "knife";
          } else if (ranVal == 2) {
            return "sword";
          } else if (ranVal == 3) {
            return "axe";
          } else if (ranVal == 4) {
            return "spear";
          } else if (ranVal == 5) {
            return "bow";
          } else if (ranVal == 6) {
            return "wand";
          } else if (ranVal == 7) {
            return "clothArmor";
          } else if (ranVal == 8) {
            return "ironArmor";
          } else if (ranVal == 9) {
            return "damagePotion";
          } else if (ranVal == 10) {
            return "healthPotion";
          } else if (ranVal == 11) {
            return "attackRangePotion";
          } else if (ranVal == 12) {
            return "attackSpeedPotion";
          } else {
            return "experience";
          }
        }
      }

      var tileTypes = [
        { name: "Home", color: "#ff9f60", symbol: "‚ñ≤", act: "_sleep" },
        { name: "Dirt", color: "#aaff80", symbol: "#", act: "" },
        { name: "Rock", color: "#8c8c8c", symbol: "‚ô¶", act: "" },
        { name: "Tree", color: "#b32400", symbol: "‚ô£", act: "", value: 0 },
        {
          name: "Water",
          color: "#EEEEFF",
          backgroundColor: "#42e5f4",
          symbol: "~~",
          act: "_water",
        },
        { name: "Carrot", color: "#ffb84d", symbol: "#", act: "Carrot" },
        {
          name: "Path",
          color: "#d68563",
          backgroundColor: "#ffb619",
          symbol: "#",
        },
        {
          name: "Up",
          color: "#ffffff",
          backgroundColor: "#bfbfbf",
          symbol: "^",
          canWalk: true,
        },
        {
          name: "Down",
          color: "#ffffff",
          backgroundColor: "#bfbfbf",
          symbol: "v",
          canWalk: true,
        },
        {
          name: "Left",
          color: "#ffffff",
          backgroundColor: "#bfbfbf",
          symbol: "<",
          canWalk: true,
        },
        {
          name: "Right",
          color: "#ffffff",
          backgroundColor: "#bfbfbf",
          symbol: ">",
          canWalk: true,
        },

        // TODO add dungeons
        {
          name: "Town",
          color: "#997300",
          backgroundColor: "#cc9900",
          symbol: "üè∞",
          canWalk: true,
        },
        {
          name: "Dungeongrass",
          color: "#051405",
          backgroundColor: "#cc9900",
          symbol: "üèØ",
          canWalk: true,
        },
        // TODO add shops
        {
          name: "ArmorShop",
          color: "#051405",
          backgroundColor: "#cc9900",
          symbol: "üèûÔ∏è",
          canWalk: true,
        },
        {
          name: "ItemShop",
          color: "#051405",
          backgroundColor: "#cc9900",
          symbol: "üèûÔ∏è",
          canWalk: true,
        },
        // TODO add quests
        {
          name: "Quest1",
          color: "#051405",
          backgroundColor: "#cc9900",
          symbol: "üåü",
          canWalk: true,
        },
        {
          name: "Quest2",
          color: "#051405",
          backgroundColor: "#cc9900",
          symbol: "üåü",
          canWalk: true,
        },
      ];

      var specialTiles = [];
      function updateSpecialTiles() {
        specialTiles = [
          { i: 0, j: Math.round(worldSize / 2), type: "Up" },
          {
            i: worldSize + 1,
            j: Math.round(worldSize / 2),
            type: "Down",
          },
          { i: Math.round(worldSize / 2), j: 0, type: "Left" },
          {
            i: Math.round(worldSize / 2),
            j: worldSize + 1,
            type: "Right",
          },
        ];

        var addVal = {};

        var d = curWorldCoordDungeon();
        if (d != "") {
          addVal = {
            i: randomRange(1, worldSize),
            j: randomRange(1, worldSize),
            type: d,
          };
          specialTiles.push(addVal);
        }

        var q = curWorldCoordQuests();
        if (q != "") {
          addVal = {
            i: randomRange(1, worldSize),
            j: randomRange(1, worldSize),
            type: q,
          };
          specialTiles.push(addVal);
        }

        if (activeDungeon == 0) {
          addVal = {
            i: randomRange(1, worldSize),
            j: randomRange(1, worldSize),
            type: "ItemShop",
          };
          specialTiles.push(addVal);
        }
      }

      var movingCreatures = [];

      $(document).ready(function () {
        init();
      });

      function init() {
        worldTable = document.getElementById("world");
        creaturesParent = document.getElementById("creatures");
        envJsons = [
          lavaCanyon,
          celestialRealm,
          enchantedForest,
          lavaFortress,
          crystalCaverns,
          mistyMoorlands,
          whisperingWoods,
          timelessDesert,
          frozenTundra,
          heartland,
          luminousGlades,
          floatingIslands,
          elementalWasteland,
          rockyHighlands,
          mysticCaverns,
          ancientRuins,
          whisperingSands,
          underwaterCity,
          darkAbyss,
          Town,
          Dungeongrass,
        ];
        worldCoords = [worldMapSize / 2, worldMapSize / 2];

        createWorldData();
        drawWorld();
        createCreature("player", 0, 0);
        createCreatures();

        firstArea = false;
      }

      function createWorldData() {
        baseEnvJson = envJsons[getCurEnvJsonId()];

        worldSize = baseEnvJson.environment.worldSize;
        updateSpecialTiles();

        baseEnvJson.prop_types.forEach((type, index) => {
          noise.seed(seed * index);

          var smoothness = type.smoothness || defaultSmoothness;

          for (i = 0; i < worldSize + 2; i++) {
            if (!worldData[i]) {
              worldData.push([]);
            }
            for (j = 0; j < worldSize + 2; j++) {
              if (!worldData[i][j]) {
                // TODO fix only first prop_type (group) being considered
                const noiseX =
                  (i + worldCoords[0] * (worldSize + 2)) / defaultSmoothness;
                const noiseY =
                  (j + worldCoords[1] * (worldSize + 2)) / defaultSmoothness;

                var tile;
                if (Math.abs(noise.simplex2(noiseX, noiseY)) >= type.rarity) {
                  tile = createTile(
                    i + "_" + j,
                    getStartingTileType(i, j, type.name)
                  );
                } else {
                  tile = createTile(
                    i + "_" + j,
                    getStartingTileType(i, j, null)
                  );
                }
                tile.id = i + "_" + j;
                worldData[i].push(tile);
              }
            }
          }
        });

        /* for (i = 0; i < worldSize + 2; i++) {
          if (!worldData[i]) {
            worldData.push([]);
          }
          for (j = 0; j < worldSize + 2; j++) {
            if (!worldData[i][j]) {
              var tile = createTile(i + "_" + j, getStartingTileType(i, j));
              tile.id = i + "_" + j;
              worldData[i].push(tile);
            }
          }
        } */

        document.getElementById("worldDiv").innerHTML =
          (activeDungeon < 0
            ? envJsons[getCurEnvJsonId()].environment.name +
              "<br>(X: " +
              worldCoords[0] +
              ", Y: " +
              worldCoords[1] +
              ")"
            : getCurDungeon() +
              "<br>(X: " +
              (worldCoords[0] - saveWorldCoords[0]) +
              ", Y: " +
              (worldCoords[1] - saveWorldCoords[1]) +
              ")") +
          "<br><br>World Map:<br>" +
          worldMapString();

        updateStats();
        enableBars(true, 1000);

        createTimestamp = Date.now();
        areaCollections = 0;
      }
      function recreateWorldData(playerDir) {
        worldSize = baseEnvJson.environment.worldSize;
        //updateSpecialTiles();

        worldData = [];
        clearCreatures();
        selTile = null;
        selCreature = null;

        var playerPosX = 0;
        var playerPosY = 0;
        if (playerDir == "down") {
          playerPosX = Math.round(worldSize / 2);
          playerPosY = worldSize + 1;

          worldCoords = [worldCoords[0], worldCoords[1] + 1];
        } else if (playerDir == "up") {
          playerPosX = Math.round(worldSize / 2);
          playerPosY = 0;

          worldCoords = [worldCoords[0], worldCoords[1] - 1];
        } else if (playerDir == "right") {
          playerPosX = worldSize + 1;
          playerPosY = Math.round(worldSize / 2);

          worldCoords = [worldCoords[0] - 1, worldCoords[1]];
        } else if (playerDir == "left") {
          playerPosX = 0;
          playerPosY = Math.round(worldSize / 2);

          worldCoords = [worldCoords[0] + 1, worldCoords[1]];
        } else {
          playerPosX = Math.round(worldSize / 2);
          playerPosY = Math.round(worldSize / 2);

          worldCoords = [worldCoords[0], worldCoords[1]];
        }

        createWorldData();
        drawWorld();

        createCreature("player", playerPosY, playerPosX);

        createCreatures();

        removeBuffs();

        setBlock(false);

        //updateStats();
        //enableBars(true, 1000);
      }

      function worldMapString() {
        var wCID = getCurEnvJsonId();
        if (wCID == 1) {
          return (
            "(CR) - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 2) {
          return (
            "CR - ? - (EF) - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 3) {
          return (
            "CR - ? - EF - ? - (LF)" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 4) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>(CC) - ? - MM - ? - WW" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 5) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - (MM) - ? - WW" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 6) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - (WW)" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 7) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>(TD) - FT - HL - LG - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 8) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - (FT) - HL - LG - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 9) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - (HL) - LG - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 10) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - HL - (LG) - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 11) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - HL - LG - (FI)" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 12) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>(EW) - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 13) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>EW - (RH) - ? - MC - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 14) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>EW - RH - ? - (MC) - AR" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 15) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>EW - RH - ? - MC - (AR)" +
            "<br>WS - ? - UC - ? - DA"
          );
        } else if (wCID == 16) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>(WS) - ? - UC - ? - DA"
          );
        } else if (wCID == 17) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - (UC) - ? - DA"
          );
        } else if (wCID == 18) {
          return (
            "CR - ? - EF - ? - LF" +
            "<br>CC - ? - MM - ? - WW" +
            "<br>TD - FT - HL - LG - FI" +
            "<br>EW - RH - ? - MC - AR" +
            "<br>WS - ? - UC - ? - (DA)"
          );
        } else {
          return "? ? ? ? ?<br>? ? ? ? ?<br>? ? ? ? ?<br>? ? ? ? ?<br>? ? ? ? ?";
        }
      }

      function secondsSinceCreate() {
        const currentTime = Date.now();
        const timeDifference = currentTime - createTimestamp;
        const secondsSinceCreate = Math.floor(timeDifference / 1000);
        return secondsSinceCreate;
      }

      function createCreatures() {
        if (activeDungeon >= 0) {
          var ran = randomRange(1, 100);
          if (ran <= dungeonInfo[getCurDungeon()].bossChance) {
            spawnBoss();
            return;
          }
        }

        eC = randomRange(0, baseEnvJson.environment.enemyCount);
        for (h = 0; h < eC; h++) {
          createCreature(
            baseEnvJson.creature_types[
              randomRange(0, baseEnvJson.creature_types.length - 1)
            ].name,
            Math.round(randomRange(0, worldSize)),
            Math.round(randomRange(0, worldSize))
          );
        }
      }

      function drawWorld() {
        var worldString = "";
        for (i = 0; i < worldData.length; i++) {
          worldString += "<tr>";
          for (j = 0; j < worldData[i].length; j++) {
            var tile = worldData[i][j];
            worldString += createTileString(tile);
          }
          worldString += "</tr>";
        }
        worldTable.innerHTML = worldString;
      }

      function createTile(idString, tileType) {
        return {
          id: idString,
          type: tileType,
          creature: "",
        };
      }

      function getStartingTileType(i, j, suggestion) {
        var specialTile = specialTiles.find(function (e) {
          return e.i == i && e.j == j;
        });
        if (specialTile) {
          return getTileType(specialTile.type);
        }

        var suggestedTile = baseEnvJson.prop_types.find(function (e) {
          return e.name == suggestion;
        });
        if (suggestedTile) {
          return suggestedTile;
        }

        if (!specialTile && Math.random() > baseEnvJson.prop_types[1].rarity) {
          //return getTileType("Rock");
          return baseEnvJson.prop_types[1];
        }
        if (!specialTile && Math.random() > baseEnvJson.prop_types[2].rarity) {
          return baseEnvJson.prop_types[2];
        }

        return baseEnvJson.floor_tile;
      }

      function getTileType(typeName) {
        return (type = tileTypes.find(function (e) {
          return e.name == typeName;
        }));
      }
      function setTileType(id, tileTypeString) {
        var idParts = id.split("_");

        if (
          (idParts[0] == "0" && idParts[1] == "0") ||
          (idParts[0] == "0" && idParts[1] == "1")
        ) {
          return false;
        }

        worldData[idParts[0]][idParts[1]] = createTile(
          id,
          getTileType(tileTypeString)
        );

        drawWorld();

        return true;
      }

      function clickTile(id) {
        var idParts = id.split("_");
        var tile = worldData[idParts[0]][idParts[1]];

        //actOnTile(tile);

        // if (selCreature) {
        //   setSelCreature(selCreature);
        // }
        setSelTile(tile);
      }
      function clickCreature(creatureName, creatureNum) {
        var creatureElement = document.getElementById(
          creatureName + creatureNum.toString()
        );

        // if (selTile) {
        //   setSelTile(selTile);
        // }
        setSelCreature(creatureElement);
      }

      function setSelTile(tile) {
        if (!tile.type.canWalk) {
          if (areaCollections < 4) {
            if (tile.type.isOre) {
              doOre();
            } else if (tile.type.isHerb) {
              doHerb();
            } else if (tile.type.isWater) {
              doWater();
            } else {
              return;
            }
          } else {
            return;
          }
        }

        if (selTile != tile) {
          selTile = tile;
        } else {
          selTile = null;
        }
        drawWorld();
      }
      function setSelCreature(creature) {
        if (selCreature) {
          selCreature.style.backgroundColor = "";
        }

        if (selCreature != creature) {
          selCreature = creature;
          selCreature.style.backgroundColor = "rgba(255, 255, 102, 0.5)";
        } else {
          selCreature = null;
        }
      }

      function doOre() {
        var ranOre = randomRange(1, 100);
        if (ranOre < 20) {
          addItem(
            "experience",
            randomRange(1, Math.max(baseEnvJson.environment.danger, 1) * 4)
          );
        }
        areaCollections += 1;

        var playerElement = document.getElementById("player1");
        createWarning("mining", playerElement, 2000);
      }
      function doHerb() {
        var ranHerb = randomRange(1, 100);
        if (ranHerb < 20) {
          addItem(
            "healthPotion",
            randomRange(1, Math.max(baseEnvJson.environment.danger, 1))
          );
        }
        areaCollections += 1;

        var playerElement = document.getElementById("player1");
        createWarning("collecting", playerElement, 2000);
      }
      function doWater() {
        var ranFish = randomRange(1, 100);
        if (ranFish < 20) {
          var ranFishVal = randomRange(1, 4);
          if (ranFishVal == 1) {
            addItem("damagePotion", 1);
          } else if (ranFishVal == 2) {
            addItem("healthPotion", 1);
          } else if (ranFishVal == 3) {
            addItem("attackSpeedPotion", 1);
          } else if (ranFishVal == 4) {
            addItem("attackRangePotion", 1);
          }
        }
        areaCollections += 1;

        var playerElement = document.getElementById("player1");
        createWarning("fishing", playerElement, 2000);
      }

      function getTileTypeName(tileType) {
        var type = tileTypes.find(function (e) {
          return e.name == tileType.name;
        });
        return type.name;
      }

      function getPlayerTile() {
        for (i = 0; i < worldSize + 2; i++) {
          for (j = 0; j < worldSize + 2; j++) {
            if (worldData[i][j].creature == "player1") {
              return worldData[i][j];
            }
          }
        }
      }
      function getCreatureTile(creature) {
        for (i = 0; i < worldSize + 2; i++) {
          for (j = 0; j < worldSize + 2; j++) {
            if (worldData[i][j].creature == creature.title) {
              return worldData[i][j];
            }
          }
        }
      }
      function getTileCreature(id) {
        var idParts = id.split("_");

        return worldData[idParts[0]][idParts[1]].creature;
      }
      function setTileCreature(id, creature) {
        var idParts = id.split("_");
        var tile = worldData[idParts[0]][idParts[1]];

        tile.creature = creature;
      }

      function actOnTile(tile) {
        if (!tile.type.act || tile.type.act == "") {
          return;
        }

        if (tile.type.act.substring(0, 1) == "_") {
          doSpecialAction(tile);
          return;
        } else {
          tile.type = getTileType(tile.type.act);

          drawWorld();
        }
      }
      function doSpecialAction(tile) {
        // TODO
        if (tile.type.act == "_sleep") {
          console.log("sleeping!");
        }

        drawWorld();
      }

      function createCreature(creatureName, posX, posY) {
        numCreatures++;
        if (numCreatures > 100) {
          // Set to 2 because player is 1
          numCreatures = 2;
        }

        // TODO multiplication by 25 should be based off tile width and spacing
        let div = document.createElement("div");
        if (creatureName == "player") {
          div.innerHTML =
            '<p style="top:' +
            posX * 25 +
            "; left:" +
            posY * 25 +
            '" id="creatureTBD" class="creature" title="creatureTBD">üßô‚Äç‚ôÇÔ∏è</p>';
        } else {
          div.innerHTML =
            "<p " +
            "data-health=" +
            getCreatureByName(creatureName).health *
              Math.max(baseEnvJson.environment.danger, 1) +
            " onclick=clickCreature('" +
            creatureName +
            "','" +
            numCreatures.toString() +
            "')" +
            ' style="top:' +
            posX * 25 +
            "; left:" +
            posY * 25 +
            '" id="creatureTBD" class="creature" title="creatureTBD">' +
            getCreatureByName(creatureName).symbol +
            "</p>";
        }

        div.firstChild.id = creatureName + numCreatures.toString();
        div.firstChild.title = creatureName + numCreatures.toString();

        if (creatureName != "player") {
          div.firstChild.style.color = getCreatureByName(creatureName).color;
        }

        creaturesParent.appendChild(div);

        /* if (creatureName == "player" && !firstArea) {
          return;
        } */

        chooseNextAIAction(creatureName + numCreatures.toString());

        updateCreatureJSON(div.firstChild);
      }
      function clearCreatures() {
        while (creaturesParent.firstChild) {
          creaturesParent.removeChild(creaturesParent.firstChild);
        }
        numCreatures = 0;

        creatureJSON = {};
      }
      function getCreatureByName(name) {
        var dI = dungeonInfo[getCurDungeon()];
        if (dI) {
          if (dI.boss.name == name) {
            return dI.boss;
          }
        }

        for (const creature of baseEnvJson.creature_types) {
          if (creature.name == name) {
            return creature;
          }
        }
        return null;
      }
      function creatureMoving(creature) {
        for (q = 0; q < movingCreatures.length; q++) {
          if (movingCreatures[q] == creature) {
            return true;
          }
        }
        return false;
      }

      function checkObjectType(obj) {
        if (typeof obj === "object") {
          if (obj instanceof HTMLElement) {
            return "creature";
          } else {
            return "tile";
          }
        } else {
          return "neither";
        }
      }

      function chooseNextAIAction(creature) {
        var creatureElement = document.getElementById(creature);
        if (!creatureElement) {
          return;
        }

        var tile;
        if (creature.startsWith("player")) {
          if (selTile != null) {
            tile = selTile;
          } else {
            tile = selCreature;
          }
        } else {
          if (Math.random() < 0.2 && baseEnvJson.environment.danger > 0) {
            createWarning("!", creatureElement, 2000);
            setTimeout(() => {
              createEffect(
                "üí•",
                creatureElement,
                document.getElementById("player1")
              );
            }, 2000);
          }

          tile = findRandomTile();
        }

        // If there is no logical tile to work
        if (!tile) {
          tile = findRandomTile();
        }

        moveCreature(
          creature,
          tile /* findRandomTileOfType(tile.type.name) */,
          !creature.startsWith("player")
        );
      }
      function moveCreature(creature, targetOrTile, doWork) {
        if (!targetOrTile) {
          return;
        }

        var isTile = checkObjectType(targetOrTile) == "tile";

        var creatureElement = document.getElementById(creature);
        var targetElement;

        if (isTile) {
          targetElement = document.getElementById(targetOrTile.id);

          if (!targetOrTile.type.canWalk) {
            if (!creature.startsWith("player")) {
              chooseNextAIAction(creature);
              return;
            }
          }
        } else {
          targetElement = targetOrTile;
        }

        if (!creatureElement) {
          return;
        }

        if (creatureMoving(creature)) {
          return;
        }
        movingCreatures.push(creature);

        if (isTile) {
          setTileCreature(targetOrTile.id, creature);
        }

        var posY = creatureElement.offsetTop - 20;
        var posX = creatureElement.offsetLeft;
        var interval = setInterval(frame, 10);
        function frame() {
          if (!document.body.contains(targetElement)) {
            if (isTile) {
              targetElement = document.getElementById(targetOrTile.id);
            } else {
              targetElement = targetOrTile;
            }
          }

          // stop creature from moving to corner when loses target
          if (targetElement.offsetTop == 0) {
            var ranTile = findRandomTile();
            targetElement = document.getElementById(ranTile.id);
          }

          tilePosY = targetElement.offsetTop - 14;
          tilePosX = targetElement.offsetLeft + 7;

          if (checkPosition(posX, tilePosX, posY, tilePosY)) {
            clearInterval(interval);
            setTimeout(
              function () {
                if (creature.startsWith("player") && isTile) {
                  if (targetOrTile.type.name == "Up") {
                    recreateWorldData("down");
                  } else if (targetOrTile.type.name == "Down") {
                    recreateWorldData("up");
                  } else if (targetOrTile.type.name == "Left") {
                    recreateWorldData("right");
                  } else if (targetOrTile.type.name == "Right") {
                    recreateWorldData("left");
                  }
                }

                if (doWork) {
                  actOnTile(targetOrTile);
                }

                if (isTile) {
                  setTileCreature(targetOrTile.id, "");
                }

                movingCreatures = movingCreatures.filter(
                  (item) => item !== creature
                );

                chooseNextAIAction(creature);
              },
              doWork ? workSpeed : 500
            );
          } else {
            if (posY < tilePosY) {
              creatureElement.style.top = posY += walkSpeed;
            } else if (posY > tilePosY) {
              creatureElement.style.top = posY -= walkSpeed;
            }

            if (posX < tilePosX) {
              creatureElement.style.left = posX += walkSpeed;
            } else if (posX > tilePosX) {
              creatureElement.style.left = posX -= walkSpeed;
            }
          }
        }
      }

      function createWarning(symbol, creatureElement, removeTime) {
        numWarnings++;
        if (numWarnings > 100) {
          numWarnings = 1;
        }

        let div = document.createElement("div");
        div.innerHTML =
          '<p id="warning" class="effect" title="warning">' +
          symbol.toString() +
          "</p>";

        div.firstChild.id = "warning" + numWarnings.toString();
        div.firstChild.title = "warning" + numWarnings.toString();
        creaturesParent.appendChild(div);

        moveWarning(
          "warning" + numWarnings.toString(),
          creatureElement,
          removeTime
        );
      }
      function moveWarning(warning, sourceElement, removeTime) {
        var warningElement = document.getElementById(warning);

        if (!warningElement) {
          return;
        }

        if (sourceElement != null) {
          warningElement.style.top = sourceElement.offsetTop - 30;
          warningElement.style.left = sourceElement.offsetLeft + 5;
        }

        var posY = warningElement.offsetTop - 20;
        var posX = warningElement.offsetLeft;
        var interval = setInterval(frame, 10);

        setTimeout(() => {
          removeWarning(warningElement, interval);
        }, removeTime);

        function frame() {
          var targetPosY = sourceElement.offsetTop - 30;
          var targetPosX = sourceElement.offsetLeft + 5;

          if (!checkPosition(posX, targetPosX, posY, targetPosY)) {
            if (posY < targetPosY) {
              warningElement.style.top = posY += walkSpeed * 1.5;
            } else if (posY > targetPosY) {
              warningElement.style.top = posY -= walkSpeed * 1.5;
            }

            if (posX < targetPosX) {
              warningElement.style.left = posX += walkSpeed * 1.5;
            } else if (posX > targetPosX) {
              warningElement.style.left = posX -= walkSpeed * 1.5;
            }
          }
        }
      }
      function removeWarning(warning, interval) {
        clearInterval(interval);
        warning.remove();
      }

      function createEffect(char, source, target) {
        numEffects++;
        if (numEffects > 100) {
          numEffects = 1;
        }

        let div = document.createElement("div");
        div.innerHTML =
          '<p id="effect" class="effect" title="effect">' + char + "</p>";

        div.firstChild.id = "effect" + numEffects.toString();
        div.firstChild.title = "effect" + numEffects.toString();
        creaturesParent.appendChild(div);

        moveEffect("effect" + numEffects.toString(), source, target);
      }
      function moveEffect(effect, sourceElement, targetElement) {
        if (!targetElement) {
          return;
        }

        var effectElement = document.getElementById(effect);
        if (!effectElement) {
          return;
        }

        if (sourceElement != null) {
          effectElement.style.top = sourceElement.style.top;
          effectElement.style.left = sourceElement.style.left;
        }

        var targetCoords = [targetElement.offsetTop, targetElement.offsetLeft];

        var posY = effectElement.offsetTop - 20;
        var posX = effectElement.offsetLeft;
        var interval = setInterval(frame, 10);
        function frame() {
          // tilePosY = targetElement.offsetTop - 14;
          // tilePosX = targetElement.offsetLeft + 7;
          tilePosY = targetCoords[0] - 14;
          tilePosX = targetCoords[1] + 7;

          if (checkPosition(posX, tilePosX, posY, tilePosY)) {
            clearInterval(interval);
            setTimeout(function () {
              effectElement.parentElement.remove();
              if (
                getDistanceBetweenElementAndPoint(targetElement, targetCoords) <
                20
              ) {
                playerDamage(baseEnvJson.environment.danger);
              }
            }, 500);
          } else {
            if (posY < tilePosY) {
              effectElement.style.top = posY += walkSpeed * 1.5;
            } else if (posY > tilePosY) {
              effectElement.style.top = posY -= walkSpeed * 1.5;
            }

            if (posX < tilePosX) {
              effectElement.style.left = posX += walkSpeed * 1.5;
            } else if (posX > tilePosX) {
              effectElement.style.left = posX -= walkSpeed * 1.5;
            }
          }
        }
      }

      function getCreatureDistanceToTile(creature, i, j) {
        var creatureElement = document.getElementById(creature);
        var worldTile = document.getElementById(i + "_" + j);

        distX = worldTile.offsetLeft - creatureElement.offsetLeft;
        distY = worldTile.offsetTop - creatureElement.offsetTop;
        distance = Math.sqrt(distX * distX + distY * distY);
        return distance;
      }
      function getDistanceBetweenElements(i, j) {
        distX = i.offsetLeft - j.offsetLeft;
        distY = i.offsetTop - j.offsetTop;
        distance = Math.sqrt(distX * distX + distY * distY);
        return distance;
      }
      function getDistanceBetweenElementAndPoint(i, point) {
        distX = i.offsetLeft - point[1];
        distY = i.offsetTop - point[0];
        distance = Math.sqrt(distX * distX + distY * distY);
        return distance;
      }

      function findTileOfType(typeName) {
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            if (worldData[i][j].type.name == typeName) {
              return worldData[i][j];
            }
          }
        }
      }
      function findNearestTileOfType(creature, typeName) {
        var minDistance = 9999;
        var currentTile;
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            if (
              worldData[i][j].type.name == typeName &&
              getCreatureDistanceToTile(creature, i, j) < minDistance
            ) {
              minDistance = getCreatureDistanceToTile(creature, i, j);
              currentTile = worldData[i][j];
            }
          }
        }

        return currentTile;
      }
      /*function findValuedTile(creature) {
        var minDistance = 9999;
        var currentTile;
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            if (
              worldData[i][j].type.hasOwnProperty("value") &&
              worldData[i][j].type.value > 0 &&
              getCreatureDistanceToTile(creature, i, j) < minDistance
            ) {
              minDistance = getCreatureDistanceToTile(creature, i, j);
              currentTile = worldData[i][j];
            }
          }
        }
        return currentTile;
      }*/
      /* function findWorkableTile(creature, baseName) {
        var minDistance = 9999;
        var currentTile;
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            if (
              !(
                "Water Path Pen " +
                (baseName + "Home") +
                " Store Rock"
              ).includes(worldData[i][j].type.name) &&
              !worldData[i][j].watered &&
              getCreatureDistanceToTile(creature, i, j) < minDistance
            ) {
              minDistance = getCreatureDistanceToTile(creature, i, j);
              currentTile = worldData[i][j];
            }
          }
        }
        return currentTile;
      } */
      function findRandomTile() {
        return worldData[randomRange(0, worldSize - 1)][
          randomRange(0, worldSize - 1)
        ];
      }
      function findRandomTileOfType(typeName) {
        var rVal = 0;
        var currentTile;
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            var randomVal = Math.random();
            if (worldData[i][j].type.name == typeName && randomVal > rVal) {
              rVal = randomVal;
              currentTile = worldData[i][j];
            }
          }
        }
        return currentTile;
      }
      function findTileWithCreature(creature) {
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            if (worldData[i][j].creature.startsWith(creature)) {
              return worldData[i][j];
            }
          }
        }
      }
      function findTileWithID(id) {
        for (i = 0; i < worldSize; i++) {
          for (j = 0; j < worldSize; j++) {
            if (worldData[i][j].id == id) {
              return worldData[i][j];
            }
          }
        }
      }

      function checkPosition(x, x2, y, y2) {
        return Math.abs(x - x2) + Math.abs(y - y2) < walkSpeed + 0.5;
      }
      function randomRange(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function playerAttack() {
        if (!selCreature) {
          return;
        }

        var attackRange = Math.max(30 * getStat("attackRange", false), 30);
        var shooting = getStat("attackRange", false) > 3;

        var playerElement = document.getElementById("player1");
        if (
          getDistanceBetweenElements(playerElement, selCreature) <= attackRange
        ) {
          if (shooting) {
            createEffect("üí•", playerElement, selCreature);
          }

          selCreature.dataset.health -= getStat("damage", false);
          createWarning("hit", playerElement, 400);

          if (selCreature.dataset.health <= 0) {
            creatureDeath(selCreature);
          } else {
            updateCreatureJSON(selCreature);
          }
        } else {
          createWarning("range", playerElement, 500);
        }

        if (equippedWeapon != "") {
          var ranLevel = randomRange(1, 100);
          if (ranLevel <= 6) {
            levelUpTypeLevel(equippedWeapon);
            createWarning("level up " + equippedWeapon, playerElement, 1000);
          }
          ranLevel = randomRange(1, 100);
          if (ranLevel <= 6) {
            levelUpTypeLevel(equippedArmor);
            createWarning("level up " + equippedArmor, playerElement, 1000);
          }

          var ranBreak = randomRange(1, 100);
          if (ranBreak <= getEquippedWeapon().breakChance) {
            removeItem(equippedWeapon, 1);
            createWarning("broke", playerElement, 800);
          }
        }
      }
      function creatureDeath(creature) {
        updateCreatureJSON(creature);

        var drop = getCreatureDrop(creature);
        if (drop != "") {
          addItem(drop, 1);
        }

        creaturesParent.removeChild(creature.parentElement);

        selCreature = null;

        tryProgressQuests("creature", creature.id);
      }

      function getStat(stat, excludeBuffs) {
        if (stat == "attackRange") {
          return (
            getEquippedWeapon().range +
            getEquippedArmor().range +
            getEquippedItem().range +
            getEquippedPotion().range +
            (!excludeBuffs
              ? getItemAmount("attackRangeBuff") *
                getStatTypeLevel("attackRangePotion")
              : 0)
          );
        } else if (stat == "damage") {
          return (
            getStatTypeLevel(equippedWeapon) *
            (getEquippedWeapon().damage +
              getEquippedArmor().damage +
              getEquippedItem().damage +
              getEquippedPotion().damage +
              (!excludeBuffs
                ? getItemAmount("damageBuff") * getStatTypeLevel("damagePotion")
                : 0))
          );
        } else if (stat == "health") {
          return (
            getStatTypeLevel(equippedArmor) *
            (getEquippedWeapon().health +
              getEquippedArmor().health +
              getEquippedItem().health +
              getEquippedPotion().health +
              (!excludeBuffs
                ? getItemAmount("healthBuff") * getStatTypeLevel("healthPotion")
                : 0))
          );
        } else if (stat == "attackSpeed") {
          return (
            getEquippedWeapon().attackSpeed +
            getEquippedArmor().attackSpeed +
            getEquippedItem().attackSpeed +
            getEquippedPotion().attackSpeed +
            (!excludeBuffs
              ? getItemAmount("attackSpeedBuff") *
                getStatTypeLevel("attackSpeedPotion")
              : 0)
          );
        }
      }

      function levelUpTypeLevel(statType) {
        if (statType == "knife") {
          knifeLevel += 1;
        } else if (statType == "sword") {
          swordLevel += 1;
        } else if (statType == "axe") {
          axeLevel += 1;
        } else if (statType == "spear") {
          spearLevel += 1;
        } else if (statType == "bow") {
          bowLevel += 1;
        } else if (statType == "wand") {
          wandLevel += 1;
        } else if (statType == "clothArmor") {
          clothArmorLevel += 1;
        } else if (statType == "ironArmor") {
          ironArmorLevel += 1;
        } else if (statType == "damagePotion") {
          damagePotionLevel += 1;
        } else if (statType == "healthPotion") {
          healthPotionLevel += 1;
        } else if (statType == "attackSpeedPotion") {
          attackSpeedPotionLevel += 1;
        } else if (statType == "attackRangePotion") {
          attackRangePotionLevel += 1;
        }

        updateStats();
      }
      function getStatTypeLevel(statType) {
        if (statType == "knife") {
          return knifeLevel;
        } else if (statType == "sword") {
          return swordLevel;
        } else if (statType == "axe") {
          return axeLevel;
        } else if (statType == "spear") {
          return spearLevel;
        } else if (statType == "bow") {
          return bowLevel;
        } else if (statType == "wand") {
          return wandLevel;
        } else if (statType == "clothArmor") {
          return clothArmorLevel;
        } else if (statType == "ironArmor") {
          return ironArmorLevel;
        } else if (statType == "damagePotion") {
          return damagePotionLevel;
        } else if (statType == "healthPotion") {
          return healthPotionLevel;
        } else if (statType == "attackSpeedPotion") {
          return attackSpeedPotionLevel;
        } else if (statType == "attackRangePotion") {
          return attackRangePotionLevel;
        } else {
          return 1;
        }
      }

      function changeStat(stat, amount) {
        if (stat == "health") {
          health += amount;

          if (health <= 0) {
            playerDeath();
          }
        }

        updateStats();
      }
      function playerDamage(amount) {
        if (secondsSinceCreate() < 5) {
          return;
        }

        if (!blocking) {
          changeStat("health", -amount);
        } else {
          setBlock(false);
        }
      }

      function playerDeath() {
        health = 10 + getStat("health", false);

        leaveDungeon();

        recreateWorldData("none");
      }

      function updateCreatureJSON(creature) {
        if (creature.id.startsWith("player")) {
          return;
        }

        if (!creature.dataset.health) {
          return;
        }

        var newItem = { name: creature.id, health: creature.dataset.health };
        creatureJSON[newItem.name] = newItem;

        updateInfoText();
      }
      function updateInfoText() {
        var retText = "";
        Object.keys(creatureJSON).forEach((key) => {
          const creature = creatureJSON[key];
          retText +=
            creature.name +
            "<br>" +
            " - health: " +
            creature.health +
            "<br><br>";
        });
        document.getElementById("creatureText").innerHTML = retText;

        retText = "";
        if (items.length > 0) {
          for (i = 0; i < items.length; i++) {
            iJson = itemsJson[items[i][0]];
            retText +=
              (menuId == i ? " > " : "") +
              (isEquipped(items[i][0]) ? "E " : "") +
              (menuId != i ? " - " : "") +
              iJson.symbol +
              " " +
              items[i][0] +
              " x" +
              items[i][1] +
              (menuId == i
                ? "<br>" +
                  iJson.type +
                  (iJson.range != 0 ? " range:" + iJson.range : "") +
                  (iJson.damage != 0 ? " damage:" + iJson.damage : "") +
                  (iJson.health != 0 ? " health:" + iJson.health : "") +
                  (iJson.attackSpeed != 0
                    ? " speed:" + iJson.attackSpeed
                    : "") +
                  (iJson.statEff.stat != "none"
                    ? "<br>effect: " +
                      iJson.statEff.stat +
                      " (" +
                      iJson.statEff.amount +
                      ")"
                    : "") +
                  "<br>"
                : "") +
              "<br>";
          }
        }
        if (quests.length > 0) {
          retText += "<br>Quests:";
          for (index = 0; index < quests.length; index++) {
            var questJson = quests[index];
            retText +=
              "<br> - " +
              questJson.name +
              "<br>" +
              questJson.target +
              " (" +
              questJson.soFar +
              " / " +
              questJson.amount +
              ")" +
              "<br>" +
              "reward: " +
              questJson.reward +
              " (" +
              questJson.rewardAmount +
              ")";
          }
        }
        document.getElementById("invText").innerHTML = retText;
      }

      // stats -- type, range, damage, health, attackSpeed, statEff, symbol
      function addItem(addItem, amount) {
        var added = false;

        for (i = 0; i < items.length; i++) {
          if (items[i][0] == addItem) {
            items[i][1] += amount;
            added = true;
          }
        }

        if (!added) {
          items.push([addItem, amount]);
        }

        tryProgressQuests("item", addItem);

        updateStats();
      }
      function removeItem(removeItem, amount) {
        for (i = 0; i < items.length; i++) {
          if (items[i][0] == removeItem) {
            items[i][1] -= amount;

            if (items[i][1] <= 0) {
              items = items.filter((item) => item[0] !== removeItem);

              if (removeItem == equippedWeapon) {
                equippedWeapon = "";
              } else if (removeItem == equippedArmor) {
                equippedArmor = "";
              } else if (removeItem == equippedPotion) {
                equippedPotion = "";
              } else if (removeItem == equippedItem) {
                equippedItem = "";
              }
            }
          }
        }

        updateStats();
      }
      function equipItem(equipItem) {
        if (!equipItem || equipItem == "") {
          return;
        }

        for (i = 0; i < items.length; i++) {
          if (items[i][0] == equipItem) {
            var iObj = itemsJson[items[i][0]];
            if (iObj.type == "weapon") {
              equippedWeapon = equippedWeapon != equipItem ? equipItem : "";
            } else if (iObj.type == "armor") {
              equippedArmor = equippedArmor != equipItem ? equipItem : "";
            } else if (iObj.type == "potion") {
              equippedPotion = equippedPotion != equipItem ? equipItem : "";
            } else if (iObj.type == "item") {
              equippedItem = equippedItem != equipItem ? equipItem : "";
            }
          }
        }

        updateStats();
      }
      function useItem(useItem) {
        if (!useItem || useItem == "") {
          buyFromShop();
          takeQuest();
          enterDungeon("");
          return;
        }

        for (i = 0; i < items.length; i++) {
          if (items[i][0] == useItem) {
            var iObj = itemsJson[items[i][0]];
            if (iObj.statEff.stat == "attackRange") {
              addItem("attackRangeBuff", iObj.statEff.amount);
            }
            if (iObj.statEff.stat == "damage") {
              addItem("damageBuff", iObj.statEff.amount);
            }
            if (iObj.statEff.stat == "health") {
              addItem("healthBuff", iObj.statEff.amount);
              health = 10 + getStat("health", false);
            }
            if (iObj.statEff.stat == "attackSpeed") {
              addItem("attackSpeedBuff", iObj.statEff.amount);
            }

            if (iObj.type == "potion") {
              var ranLevel = randomRange(1, 100);
              if (ranLevel <= 3) {
                var ranLevelType = randomRange(1, 4);
                if (ranLevelType == 1) {
                  levelUpTypeLevel("damagePotion");
                  createWarning("level up damage potion", playerElement, 1000);
                } else if (ranLevelType == 2) {
                  levelUpTypeLevel("healthPotion");
                  createWarning("level up health potion", playerElement, 1000);
                } else if (ranLevelType == 3) {
                  levelUpTypeLevel("attackSpeedPotion");
                  createWarning("level up speed potion", playerElement, 1000);
                } else if (ranLevelType == 4) {
                  levelUpTypeLevel("attackRangePotion");
                  createWarning("level up range potion", playerElement, 1000);
                }
              }

              removeItem(useItem, 1);
            } else {
              buyFromShop();
              takeQuest();
              enterDungeon(useItem);
            }

            var playerElement = document.getElementById("player1");
            createWarning("| | |", playerElement, 500);
          }
        }
      }
      function getItemAmount(amntItem) {
        for (i = 0; i < items.length; i++) {
          if (items[i][0] == amntItem) {
            return items[i][1];
          }
        }
        return 0;
      }
      function removeBuffs(removeItem, amount) {
        items = items.filter((item) => !item[0].endsWith("Buff"));

        if (health > 10 + getStat("health", true)) {
          health = 10 + getStat("health", true);
        }

        updateStats();
      }

      function buyFromShop() {
        var shopJson = shopInfo[getPlayerTile().type.name];
        if (!shopJson) {
          return;
        }

        var cost = shopJson.cost;

        if (shopJson.shopType == "level") {
          cost =
            getStatTypeLevel(shopJson.purchase) *
            getStatTypeLevel(shopJson.purchase);
        }

        if (getItemAmount("experience") < cost) {
          var playerElement = document.getElementById("player1");
          createWarning(
            "requires " + cost + " experience",
            playerElement,
            1500
          );
          return;
        }

        if (shopJson.shopType == "level") {
          levelUpTypeLevel(shopJson.purchase);

          var playerElement = document.getElementById("player1");
          createWarning("level up " + shopJson.purchase, playerElement, 1000);
        } else if (shopJson.shopType == "item") {
          addItem(shopJson.purchase, 1);

          var playerElement = document.getElementById("player1");
          createWarning("purchased " + shopJson.purchase, playerElement, 1000);
        }

        removeItem("experience", cost);
      }

      function takeQuest() {
        var questJson = questInfo[getPlayerTile().type.name];
        if (!questJson) {
          return;
        }

        for (var i = 0; i < quests.length; i++) {
          if (quests[i].name === questJson.name) {
            return;
          }
        }

        quests.push({
          name: questJson.name,
          targetType: questJson.targetType,
          target: questJson.target,
          amount: questJson.amount,
          soFar: 0,
          reward: questJson.reward,
          rewardAmount: questJson.rewardAmount,
        });

        var playerElement = document.getElementById("player1");
        createWarning("received quest: " + questJson.name, playerElement, 1000);

        updateStats();
      }
      function curWorldCoordQuests() {
        for (const key in questInfo) {
          if (
            questInfo[key].worldCoord[0] == worldCoords[0] &&
            questInfo[key].worldCoord[1] == worldCoords[1]
          ) {
            return key;
          }
        }
        return "";
      }
      function tryProgressQuests(type, target) {
        quests.forEach((quest) => {
          if (type == quest.targetType && target.startsWith(quest.target)) {
            quest.soFar++;

            if (quest.soFar >= quest.amount) {
              completeQuest(quest);
            } else {
              var playerElement = document.getElementById("player1");
              createWarning(
                quest.name + " (" + quest.soFar + " / " + quest.amount + ")",
                playerElement,
                1200
              );
            }
          }
        });

        updateStats();
      }
      function completeQuest(quest) {
        addItem(quest.reward, quest.rewardAmount);

        var playerElement = document.getElementById("player1");
        createWarning("completed " + quest.name, playerElement, 2000);

        quests = quests.filter((item) => item !== quest);

        updateStats();
      }

      function getCurDungeon() {
        if (activeDungeon < 0) {
          return "";
        }

        for (const key in dungeonInfo) {
          if (dungeonInfo[key].id == activeDungeon) {
            return key;
          }
        }
        return "";
      }
      function curWorldCoordDungeon() {
        if (activeDungeon >= 0) {
          for (const key in dungeonInfo) {
            if (
              dungeonInfo[key].worldCoord[0] == worldCoords[0] &&
              dungeonInfo[key].worldCoord[1] == worldCoords[1] &&
              dungeonInfo[key].id == activeDungeon
            ) {
              return key;
            }
          }
        } else {
          for (const key in dungeonInfo) {
            if (
              dungeonInfo[key].worldCoord[0] == worldCoords[0] &&
              dungeonInfo[key].worldCoord[1] == worldCoords[1]
            ) {
              return key;
            }
          }
        }
        return "";
      }
      function enterDungeon(keyItem) {
        var dungeonJson = dungeonInfo[getPlayerTile().type.name];
        if (!dungeonJson) {
          return;
        }

        if (activeDungeon >= 0) {
          leaveDungeon();
          return;
        }

        if (dungeonJson.reqItem != "" && dungeonJson.reqItem != keyItem) {
          var playerElement = document.getElementById("player1");
          createWarning("requires " + dungeonJson.reqItem, playerElement, 1500);
          return;
        }

        activeDungeon = dungeonJson.id;
        saveWorldCoords = worldCoords;
        recreateWorldData("none");
      }
      function leaveDungeon() {
        if (activeDungeon < 0) {
          return;
        }

        activeDungeon = -1;
        worldCoords = saveWorldCoords;
        recreateWorldData("none");
      }
      function spawnBoss() {
        var cD = dungeonInfo[getCurDungeon()];
        if (!cD) {
          return;
        }

        createCreature(
          cD.boss.name,
          Math.round(randomRange(0, worldSize)),
          Math.round(randomRange(0, worldSize))
        );
      }

      /*function save() {
        var saveString = "";

        saveString += points.toString() + "*";
        saveString += day.toString() + "*";
        saveString += numHouses.toString() + "*";
        saveString += cowHouses.toString() + "*";
        saveString += purchasedUpgradeString + "*";
        for (x = 0; x < worldSize; x++) {
          for (y = 0; y < worldSize; y++) {
            var tile = worldData[x][y];
            saveString += saveTileToString(tile) + "+";
          }
        }

        document.getElementById("save").value = saveString;
      }
      function load() {
        var loadElement = document.getElementById("load");

        var loadString = loadElement.value.split("*");

        points = parseInt(loadString[0]);
        day = parseInt(loadString[1]);
        numHouses = parseInt(loadString[2]);
        cowHouses = parseInt(loadString[3]);
        var upgradeString = loadString[4].split("+");
        for (upg = 0; upg < upgradeString.length - 1; upg++) {
          switch (upgradeString[upg]) {
            case "world":
              purchaseUpgrade(getUpgrade("world"), true);
              break;
            case "shoes":
              purchaseUpgrade(getUpgrade("shoes"), true);
              break;
            case "tool":
              purchaseUpgrade(getUpgrade("tool"), true);
              break;
            case "wc":
              purchaseUpgrade(getUpgrade("wc"), true);
              break;
            case "fertilizer":
              purchaseUpgrade(getUpgrade("fertilizer"), true);
              break;
            case "worlders":
              purchaseUpgrade(getUpgrade("worlders"), true);
              break;
            case "cows":
              purchaseUpgrade(getUpgrade("cows"), true);
              break;
          }
        }

        var worldDataString = loadString[5].split("+");
        for (fd = 0; fd < worldDataString.length - 1; fd++) {
          loadTileFromString(worldDataString[fd]);
        }

        drawWorld();
      }

      function saveTileToString(tile) {
        return tile.id + "&" + tile.watered + "&" + getTileTypeName(tile.type);
      }
      function loadTileFromString(tileString) {
        var tileData = tileString.split("&");

        setTileType(tileData[0], tileData[2]);

        var idParts = tileData[0].split("_");
        worldData[idParts[0]][idParts[1]].watered = tileData[1] === "true";
      }*/

      function createTileString(tile) {
        return (
          "<td class='tile' " +
          " id='" +
          tile.id +
          "'" +
          " style='color:" +
          tile.type.color +
          ";" +
          " background-color: " +
          getTileBackgroundColor(tile) +
          ";" +
          getBorderStyle(tile) +
          /* getOpacity(tile) */ "" +
          "; user-select: none; '" +
          " onclick='clickTile(this.id)' " +
          " title='" +
          tile.type.name +
          "'" +
          ">" +
          tile.type.symbol
        );
        ("</td>");
      }
      function getTileBackgroundColor(tile) {
        if (selTile == tile) {
          return "#ffff99";
        } else {
          return tile.type.backgroundColor
            ? tile.type.backgroundColor
            : "#ccffb3";
        }
      }
      function getTileBorderColor(tile) {
        if (selTile == tile) {
          return "#ffff99";
        } else {
          return tile.type.backgroundColor
            ? darkenColor(tile.type.backgroundColor, 20)
            : "#4ce600";
        }
      }
      function getBorderStyle(tile) {
        var tileString = "";
        var borderString = " 2pt solid " + getTileBorderColor(tile) + "; ";
        tileString += " border-bottom: " + borderString + ";";
        tileString += " border-top: " + borderString + ";";
        tileString += " border-right: " + borderString + ";";
        tileString += " border-left: " + borderString + ";";
        return tileString;
      }
      /*function getOpacity(tile) {
        if (
          parseInt(tile.id.split("_")[0]) > worldSize ||
          parseInt(tile.id.split("_")[1]) > worldSize
        ) {
          return " opacity: .2; ";
        }

        if (
          parseInt(tile.id.split("_")[0]) > worldSize - 1 ||
          parseInt(tile.id.split("_")[1]) > worldSize - 1
        ) {
          return " opacity: .5; ";
        }
        return "";
      }*/

      function darkenColor(hexColor, percentage) {
        // Remove the "#" symbol if present
        hexColor = hexColor.replace("#", "");

        // Convert the hexadecimal color to RGB values
        const r = parseInt(hexColor.substring(0, 2), 16);
        const g = parseInt(hexColor.substring(2, 4), 16);
        const b = parseInt(hexColor.substring(4, 6), 16);

        // Calculate the darker RGB values based on the percentage
        const darkerR = Math.floor(r * (1 - percentage / 100));
        const darkerG = Math.floor(g * (1 - percentage / 100));
        const darkerB = Math.floor(b * (1 - percentage / 100));

        // Convert the darker RGB values back to hexadecimal color
        const darkerHexColor =
          "#" +
          darkerR.toString(16).padStart(2, "0") +
          darkerG.toString(16).padStart(2, "0") +
          darkerB.toString(16).padStart(2, "0");

        return darkerHexColor;
      }
    </script>

    <style>
      .tile {
        width: 20px;
        height: 10px;
        text-align: center;
        font-weight: bold;
      }
      .creature {
        position: fixed;
        top: 0px;
        left: 0px;
        z-index: 2;
        color: rgb(204, 51, 0);
        text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
        font-size: 14pt;
        font-weight: bold;
        padding-top: 2px;
        padding-left: 2px;
        user-select: none;
        padding: 5px;
      }
      .effect {
        position: fixed;
        top: 0px;
        left: 0px;
        z-index: 2;
        color: #cc3300;
        text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
        font-size: 14pt;
        font-weight: bold;
        padding-top: 2px;
        padding-left: 2px;
        user-select: none;
      }
    </style>
  </head>

  <body class="container">
    <div>
      <table class="table-container" id="world"></table>
      <p id="creatures"></p>
      <div id="worldDiv" class="stats-text" style="white-space: pre"></div>
    </div>

    <div>
      <div class="panel">
        <div class="panel-content">
          <div id="itemsDiv" class="stats-text"></div>
          <br />
          <div id="statsDiv" class="stats-text"></div>
        </div>
      </div>

      <br />

      <div class="panel">
        <div class="panel-container">
          <div style="grid-area: top">
            <button id="topButton" onclick="arrowUp()">
              <span id="topText" class="button-text"></span>
              <div id="topBLoad" class="loading-bar"></div>
            </button>
          </div>
          <div style="grid-area: topLeft">
            <button id="topLeftButton" onclick="arrowUpLeft()">
              <span id="topLeftText" class="button-text">üîë</span>
              <div id="topLeftBLoad" class="loading-bar"></div>
            </button>
          </div>
          <div style="grid-area: topRight">
            <button id="topRightButton" onclick="arrowUpRight()">
              <span id="topRightText" class="button-text">üß™</span>
              <div id="topRightBLoad" class="loading-bar"></div>
            </button>
          </div>
          <div style="grid-area: left">
            <button id="leftButton" onclick="arrowLeft()">
              <span id="leftText" class="button-text"></span>
              <div id="leftBLoad" class="loading-bar"></div>
            </button>
          </div>
          <div style="grid-area: center">
            <button id="centerButton" onclick="enter()">
              <span id="blockText" class="button-text">‚öîÔ∏è</span>
              <div id="centerBLoad" class="loading-bar"></div>
            </button>
          </div>
          <div style="grid-area: right">
            <button id="rightButton" onclick="arrowRight()">
              <span id="rightText" class="button-text"></span>
              <div id="rightBLoad" class="loading-bar"></div>
            </button>
          </div>
          <div style="grid-area: bottom">
            <button id="bottomButton" onclick="arrowDown()">
              <span id="bottomText" class="button-text"></span>
              <div id="bottomBLoad" class="loading-bar"></div>
            </button>
          </div>
          <div style="grid-area: bottomLeft">
            <button id="bottomLeftButton" onclick="arrowDownLeft()">
              <span id="bottomLeftText" class="button-text">üëÅÔ∏è</span>
              <div id="bottomLeftBLoad" class="loading-bar"></div>
            </button>
          </div>
          <div style="grid-area: bottomRight">
            <button id="bottomRightButton" onclick="arrowDownRight()">
              <span id="bottomRightText" class="button-text">‚ùå</span>
              <div id="bottomRightBLoad" class="loading-bar"></div>
            </button>
          </div>
        </div>
      </div>
    </div>

    <div>
      <div class="panel">
        <div class="panel-content">
          <div id="creatureText" class="stats-text"></div>
        </div>
      </div>
      <br />
      <div class="panel">
        <div class="panel-content">
          <div id="invText" class="stats-text"></div>
        </div>
      </div>
    </div>

    <!-- <div>
      <br />
      <button onclick="save()">Save</button>
      <input id="save" style="user-select: none" />
    </div>
    <div id="loading" style="display: inline">
      <input id="load" />
      <button onclick="load()">Load</button>
    </div> -->
  </body>
</html>

<style>
  .container {
    display: inline-flex;
    overflow: hidden;
  }

  .table-container {
    width: 480px;
    padding: 0px;
  }

  .panel {
    /* width: 300px; */
    height: 200px;
    border: 1px solid #ccc;
    overflow: hidden;
    margin-left: 10px;
    justify-items: center;
    align-items: center;
  }

  .panel-container {
    display: grid;
    grid-template-areas:
      "topLeft top topRight"
      "left center right"
      "bottomLeft bottom bottomRight";
    gap: 20px;
    height: 100%;
    justify-items: center;
    align-items: center;
    background-color: #d8b68b;
  }

  .panel-content {
    width: 250px;
    padding: 10px;
    overflow-y: auto;
    height: calc(100% - 20px); /* Subtract padding */
    background-color: #d8b68b;
  }

  button {
    position: relative;
    padding: 10px 20px;
    font-size: 16px;
    background-color: #daba91;
    border: none;
    cursor: pointer;
  }

  button:disabled {
    cursor: default;
    pointer-events: all !important;
  }

  .button-text {
    font-family: fantasy, Tahoma, Geneva, Verdana, sans-serif;
    color: #827056;
    position: relative;
    z-index: 2;
  }

  .loading-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    background-color: #543c25;
    transition: width 0.5s linear;
    z-index: 1;
  }

  .stats-text {
    font-family: fantasy, Tahoma, Geneva, Verdana, sans-serif;
    color: #827056;
  }
</style>

<script>
  const blockText = document.getElementById("blockText");

  let repeatIntervalId;
  repeatIntervalId = setInterval(repeatFunction, 500);

  // Action bars
  const topButton = document.getElementById("topButton");
  const topBLoad = document.getElementById("topBLoad");
  let topCooldownTime = 5;
  const rightButton = document.getElementById("rightButton");
  const rightBLoad = document.getElementById("rightBLoad");
  let rightCooldownTime = 5;
  const bottomButton = document.getElementById("bottomButton");
  const bottomBLoad = document.getElementById("bottomBLoad");
  let bottomCooldownTime = 5;
  const leftButton = document.getElementById("leftButton");
  const leftBLoad = document.getElementById("leftBLoad");
  let leftCooldownTime = 5;
  const centerButton = document.getElementById("centerButton");
  const centerBLoad = document.getElementById("centerBLoad");
  let centerCooldownTime = 5;

  let actType = "top";
  let intervalId;

  // Top
  function topCooldown(time) {
    // actType = "top";
    // enableBars(false, time);
    // topBLoad.style.width = "0%";
    // intervalId = setInterval(updateLoadingBar, time);

    menuId--;
    if (menuId < 0) {
      menuId = 0;
    }

    updateStats();
  }
  // Left
  function leftCooldown(time) {
    // actType = "left";
    // enableBars(false, time);
    // leftBLoad.style.width = "0%";
    // intervalId = setInterval(updateLoadingBar, time);

    if (menuId < items.length) {
      useItem(items[menuId][0]);
    } else if (items.length == 0) {
      useItem("");
    }
  }
  // Right
  function rightCooldown(time) {
    if (selCreature != null) {
      if (rightButton.disabled) {
        return;
      }

      var aS = getStat("attackSpeed", false);
      if (aS == 1) {
        time = 2000;
      } else if (aS == 2) {
        time = 1500;
      } else if (aS == 3) {
        time = 1000;
      } else if (aS == 4) {
        time = 800;
      } else if (aS >= 5) {
        time = 500;
      } else {
        time = 2500;
      }

      //actType = "right";
      //enableBars(false, time);
      //rightBLoad.style.width = "0%";
      //intervalId = setInterval(updateLoadingBar, time);

      playerAttack();
      rightButton.disabled = true;
      intervalId = setInterval(enableRightButton, time);
    } else {
      if (menuId < items.length) {
        equipItem(items[menuId][0]);
      }

      updateStats();
    }
  }
  // Down
  function bottomCooldown(time) {
    // actType = "bottom";
    // enableBars(false, time);
    // bottomBLoad.style.width = "0%";
    // intervalId = setInterval(updateLoadingBar, time);

    menuId++;
    if (menuId >= items.length) {
      menuId = items.length - 1;
    }

    updateStats();
  }
  // Center
  function centerCooldown(time) {
    // actType = "center";
    // enableBars(false, time);
    // centerBLoad.style.width = "0%";
    // intervalId = setInterval(updateLoadingBar, time);

    setBlock(!blocking);
  }

  function enableRightButton() {
    clearInterval(intervalId);
    rightButton.disabled = false;
  }

  function enableBars(enable, time) {
    if (time < 0) {
      topButton.disabled = !enable;
      rightButton.disabled = !enable;
      bottomButton.disabled = !enable;
      leftButton.disabled = !enable;
      centerButton.disabled = false;
      return;
    }

    setBlock(false); // TODO remove?

    topButton.disabled = !enable;
    rightButton.disabled = !enable;
    bottomButton.disabled = !enable;
    leftButton.disabled = !enable;
    centerButton.disabled = !enable;

    topCooldownTime = time / 1000;
    rightCooldownTime = time / 1000;
    bottomCooldownTime = time / 1000;
    leftCooldownTime = time / 1000;
    centerCooldownTime = time / 1000;
    topBLoad.style.width = "100%";
    rightBLoad.style.width = "100%";
    bottomBLoad.style.width = "100%";
    leftBLoad.style.width = "100%";
    centerBLoad.style.width = "100%";
  }

  /* function updateLoadingBar(time) {
    if (actType == "top") {
      topCooldownTime--;
      topBLoad.style.width =
        "0%";
      if (topCooldownTime <= 0) {
        clearInterval(intervalId);
        enableBars(true);
      }
    } else if (actType == "right") {
      rightCooldownTime--;
      rightBLoad.style.width =
        "0%";
      if (rightCooldownTime <= 0) {
        clearInterval(intervalId);
        enableBars(true);
      }
    } else if (actType == "bottom") {
      bottomCooldownTime--;
      bottomBLoad.style.width =
        "0%";
      if (bottomCooldownTime <= 0) {
        clearInterval(intervalId);
        enableBars(true);
      }
    } else if (actType == "left") {
      leftCooldownTime--;
      leftBLoad.style.width =
        "0%";
      if (leftCooldownTime <= 0) {
        clearInterval(intervalId);
        enableBars(true);
      }
    } else if (actType == "center") {
      centerCooldownTime--;
      centerBLoad.style.width =
        "0%";
      if (centerCooldownTime <= 0) {
        clearInterval(intervalId);
        enableBars(true);
      }
    }
  } */

  function clearSel() {
    if (selCreature) {
      setSelCreature(selCreature);
    }
    if (selTile) {
      setSelTile(selTile);
    }
  }

  function setBlock(block) {
    blocking = block;
    //enableBars(!blocking, -1);
    blockText.innerHTML = blocking ? "üõ°Ô∏è" : "‚öîÔ∏è";
  }

  function repeatFunction() {
    if (blocking) {
      var playerElement = document.getElementById("player1");
      createWarning("üõ°Ô∏è", playerElement, 500);
    }

    setActionButtonsText();
  }

  function setActionButtonsText() {
    document.getElementById("topText").innerHTML =
      selCreature != null ? "üîº" : "üîº";
    document.getElementById("leftText").innerHTML =
      selCreature != null ? "üñêÔ∏è" : "üñêÔ∏è";
    //blockText.innerHTML = selCreature != null ? "üõ°Ô∏è" : "üõ°Ô∏è";
    document.getElementById("rightText").innerHTML =
      selCreature != null ? "üó°Ô∏è" : "üíº";
    document.getElementById("bottomText").innerHTML =
      selCreature != null ? "üîΩ" : "üîΩ";
  }
</script>

<script>
  /*
   * src="perlin.js"
   * A speed-improved perlin and simplex noise algorithms for 2D.
   *
   * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
   * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
   * Better rank ordering method by Stefan Gustavson in 2012.
   * Converted to Javascript by Joseph Gentle.
   *
   * Version 2012-03-09
   *
   * This code was placed in the public domain by its original author,
   * Stefan Gustavson. You may use it as you see fit, but
   * attribution is appreciated.
   *
   */

  (function (global) {
    var module = (global.noise = {});

    function Grad(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }

    Grad.prototype.dot2 = function (x, y) {
      return this.x * x + this.y * y;
    };

    Grad.prototype.dot3 = function (x, y, z) {
      return this.x * x + this.y * y + this.z * z;
    };

    var grad3 = [
      new Grad(1, 1, 0),
      new Grad(-1, 1, 0),
      new Grad(1, -1, 0),
      new Grad(-1, -1, 0),
      new Grad(1, 0, 1),
      new Grad(-1, 0, 1),
      new Grad(1, 0, -1),
      new Grad(-1, 0, -1),
      new Grad(0, 1, 1),
      new Grad(0, -1, 1),
      new Grad(0, 1, -1),
      new Grad(0, -1, -1),
    ];

    var p = [
      151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,
      140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247,
      120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
      33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165,
      71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211,
      133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25,
      63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
      135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
      226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206,
      59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248,
      152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,
      39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218,
      246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241,
      81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157,
      184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
      222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
    ];
    // To remove the need for index wrapping, double the permutation table length
    var perm = new Array(512);
    var gradP = new Array(512);

    // This isn't a very good seeding function, but it works ok. It supports 2^16
    // different seed values. Write something better if you need more seeds.
    module.seed = function (seed) {
      if (seed > 0 && seed < 1) {
        // Scale the seed out
        seed *= 65536;
      }

      seed = Math.floor(seed);
      if (seed < 256) {
        seed |= seed << 8;
      }

      for (var i = 0; i < 256; i++) {
        var v;
        if (i & 1) {
          v = p[i] ^ (seed & 255);
        } else {
          v = p[i] ^ ((seed >> 8) & 255);
        }

        perm[i] = perm[i + 256] = v;
        gradP[i] = gradP[i + 256] = grad3[v % 12];
      }
    };

    module.seed(0);

    /*
  for(var i=0; i<256; i++) {
    perm[i] = perm[i + 256] = p[i];
    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
  }*/

    // Skewing and unskewing factors for 2, 3, and 4 dimensions
    var F2 = 0.5 * (Math.sqrt(3) - 1);
    var G2 = (3 - Math.sqrt(3)) / 6;

    var F3 = 1 / 3;
    var G3 = 1 / 6;

    // 2D simplex noise
    module.simplex2 = function (xin, yin) {
      var n0, n1, n2; // Noise contributions from the three corners
      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin) * F2; // Hairy factor for 2D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var t = (i + j) * G2;
      var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
      var y0 = yin - j + t;
      // For the 2D case, the simplex shape is an equilateral triangle.
      // Determine which simplex we are in.
      var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
      if (x0 > y0) {
        // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        i1 = 1;
        j1 = 0;
      } else {
        // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        i1 = 0;
        j1 = 1;
      }
      // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
      // c = (3-sqrt(3))/6
      var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
      var y1 = y0 - j1 + G2;
      var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
      var y2 = y0 - 1 + 2 * G2;
      // Work out the hashed gradient indices of the three simplex corners
      i &= 255;
      j &= 255;
      var gi0 = gradP[i + perm[j]];
      var gi1 = gradP[i + i1 + perm[j + j1]];
      var gi2 = gradP[i + 1 + perm[j + 1]];
      // Calculate the contribution from the three corners
      var t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient
      }
      var t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * gi1.dot2(x1, y1);
      }
      var t2 = 0.5 - x2 * x2 - y2 * y2;
      if (t2 < 0) {
        n2 = 0;
      } else {
        t2 *= t2;
        n2 = t2 * t2 * gi2.dot2(x2, y2);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to return values in the interval [-1,1].
      return 70 * (n0 + n1 + n2);
    };

    // 3D simplex noise
    module.simplex3 = function (xin, yin, zin) {
      var n0, n1, n2, n3; // Noise contributions from the four corners

      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin + zin) * F3; // Hairy factor for 2D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var k = Math.floor(zin + s);

      var t = (i + j + k) * G3;
      var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
      var y0 = yin - j + t;
      var z0 = zin - k + t;

      // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
      // Determine which simplex we are in.
      var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
      var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        }
      } else {
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        }
      }
      // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
      // c = 1/6.
      var x1 = x0 - i1 + G3; // Offsets for second corner
      var y1 = y0 - j1 + G3;
      var z1 = z0 - k1 + G3;

      var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
      var y2 = y0 - j2 + 2 * G3;
      var z2 = z0 - k2 + 2 * G3;

      var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
      var y3 = y0 - 1 + 3 * G3;
      var z3 = z0 - 1 + 3 * G3;

      // Work out the hashed gradient indices of the four simplex corners
      i &= 255;
      j &= 255;
      k &= 255;
      var gi0 = gradP[i + perm[j + perm[k]]];
      var gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];
      var gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];
      var gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]];

      // Calculate the contribution from the four corners
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * gi0.dot3(x0, y0, z0); // (x,y) of grad3 used for 2D gradient
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t2 < 0) {
        n2 = 0;
      } else {
        t2 *= t2;
        n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0) {
        n3 = 0;
      } else {
        t3 *= t3;
        n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to return values in the interval [-1,1].
      return 32 * (n0 + n1 + n2 + n3);
    };

    // ##### Perlin noise stuff

    function fade(t) {
      return t * t * t * (t * (t * 6 - 15) + 10);
    }

    function lerp(a, b, t) {
      return (1 - t) * a + t * b;
    }

    // 2D Perlin Noise
    module.perlin2 = function (x, y) {
      // Find unit grid cell containing point
      var X = Math.floor(x),
        Y = Math.floor(y);
      // Get relative xy coordinates of point within that cell
      x = x - X;
      y = y - Y;
      // Wrap the integer cells at 255 (smaller integer period can be introduced here)
      X = X & 255;
      Y = Y & 255;

      // Calculate noise contributions from each of the four corners
      var n00 = gradP[X + perm[Y]].dot2(x, y);
      var n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);
      var n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);
      var n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);

      // Compute the fade curve value for x
      var u = fade(x);

      // Interpolate the four results
      return lerp(lerp(n00, n10, u), lerp(n01, n11, u), fade(y));
    };

    // 3D Perlin Noise
    module.perlin3 = function (x, y, z) {
      // Find unit grid cell containing point
      var X = Math.floor(x),
        Y = Math.floor(y),
        Z = Math.floor(z);
      // Get relative xyz coordinates of point within that cell
      x = x - X;
      y = y - Y;
      z = z - Z;
      // Wrap the integer cells at 255 (smaller integer period can be introduced here)
      X = X & 255;
      Y = Y & 255;
      Z = Z & 255;

      // Calculate noise contributions from each of the eight corners
      var n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);
      var n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);
      var n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);
      var n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);
      var n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);
      var n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);
      var n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);
      var n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(
        x - 1,
        y - 1,
        z - 1
      );

      // Compute the fade curve value for x, y, z
      var u = fade(x);
      var v = fade(y);
      var w = fade(z);

      // Interpolate
      return lerp(
        lerp(lerp(n000, n100, u), lerp(n001, n101, u), w),
        lerp(lerp(n010, n110, u), lerp(n011, n111, u), w),
        v
      );
    };
  })(this);
</script>
